var Swiper = function() {
    "use strict";

    function e(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object;
    }

    function t(s, a) {
        void 0 === s && (s = {}), void 0 === a && (a = {});
        const i = ["__proto__", "constructor", "prototype"];
        Object.keys(a).filter((e => i.indexOf(e) < 0)).forEach((i => {
            void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i]);
        }));
    }

    const s = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
            blur() {},
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {}
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };

    function a() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, s), e;
    }

    const i = {
        document: s,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
        },
        CustomEvent: function() {
            return this;
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e);
        }
    };

    function r() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, i), e;
    }

    function n(e) {
        return void 0 === e && (e = ""), e.trim().split(" ").filter((e => !!e.trim()));
    }

    function l(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t);
    }

    function o() {
        return Date.now();
    }

    function d(e, t) {
        void 0 === t && (t = "x");
        const s = r();
        let a, i, n;
        const l = function(e) {
            const t = r();
            let s;
            return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s;
        }(e);
        return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0;
    }

    function c(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1);
    }

    function p() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
            t = ["__proto__", "constructor", "prototype"];
        for (let a = 1; a < arguments.length; a += 1) {
            const i = a < 0 || arguments.length <= a ? void 0 : arguments[a];
            if (null != i && (s = i, !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) {
                const s = Object.keys(Object(i)).filter((e => t.indexOf(e) < 0));
                for (let t = 0, a = s.length; t < a; t += 1) {
                    const a = s[t],
                        r = Object.getOwnPropertyDescriptor(i, a);
                    void 0 !== r && r.enumerable && (c(e[a]) && c(i[a]) ? i[a].__swiper__ ? e[a] = i[a] : p(e[a], i[a]) : !c(e[a]) && c(i[a]) ? (e[a] = {}, i[a].__swiper__ ? e[a] = i[a] : p(e[a], i[a])) : e[a] = i[a]);
                }
            }
        }
        var s;
        return e;
    }

    function u(e, t, s) {
        e.style.setProperty(t, s);
    }

    function m(e) {
        let {
            swiper: t,
            targetPosition: s,
            side: a
        } = e;
        const i = r(),
            n = -t.translate;
        let l, o = null;
        const d = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID);
        const c = s > n ? "next" : "prev",
            p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t,
            u = () => {
                l = (new Date).getTime(), null === o && (o = l);
                const e = Math.max(Math.min((l - o) / d, 1), 0),
                    r = .5 - Math.cos(e * Math.PI) / 2;
                let c = n + r * (s - n);
                if (p(c, s) && (c = s), t.wrapperEl.scrollTo({
                        [a]: c
                    }), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                    t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                        [a]: c
                    });
                })), void i.cancelAnimationFrame(t.cssModeFrameID);
                t.cssModeFrameID = i.requestAnimationFrame(u);
            };
        u();
    }

    function h(e) {
        return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e;
    }

    function f(e, t) {
        void 0 === t && (t = "");
        const s = r(),
            a = [...e.children];
        return s.HTMLSlotElement && e instanceof HTMLSlotElement && a.push(...e.assignedElements()), t ? a.filter((e => e.matches(t))) : a;
    }

    function g(e) {
        try {
            return void console.warn(e);
        } catch (e) {}
    }

    function v(e, t) {
        void 0 === t && (t = []);
        const s = document.createElement(e);
        return s.classList.add(...Array.isArray(t) ? t : n(t)), s;
    }

    function w(e) {
        const t = r(),
            s = a(),
            i = e.getBoundingClientRect(),
            n = s.body,
            l = e.clientTop || n.clientTop || 0,
            o = e.clientLeft || n.clientLeft || 0,
            d = e === t ? t.scrollY : e.scrollTop,
            c = e === t ? t.scrollX : e.scrollLeft;
        return {
            top: i.top + d - l,
            left: i.left + c - o
        };
    }

    function b(e, t) {
        return r().getComputedStyle(e, null).getPropertyValue(t);
    }

    function y(e) {
        let t, s = e;
        if (s) {
            for (t = 0; null !== (s = s.previousSibling);) 1 === s.nodeType && (t += 1);
            return t;
        }
    }

    function E(e, t) {
        const s = [];
        let a = e.parentElement;
        for (; a;) t ? a.matches(t) && s.push(a) : s.push(a), a = a.parentElement;
        return s;
    }

    function x(e, t) {
        t && e.addEventListener("transitionend", (function s(a) {
            a.target === e && (t.call(e, a), e.removeEventListener("transitionend", s));
        }));
    }

    function S(e, t, s) {
        const a = r();
        return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth;
    }

    function T(e) {
        return (Array.isArray(e) ? e : [e]).filter((e => !!e));
    }

    function M(e) {
        return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t;
    }

    function C(e, t) {
        void 0 === t && (t = ""), "undefined" != typeof trustedTypes ? e.innerHTML = trustedTypes.createPolicy("html", {
            createHTML: e => e
        }).createHTML(t) : e.innerHTML = t;
    }

    let P, L, I;

    function z() {
        return P || (P = function() {
            const e = r(),
                t = a();
            return {
                smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
            };
        }()), P;
    }

    function A(e) {
        return void 0 === e && (e = {}), L || (L = function(e) {
            let {
                userAgent: t
            } = void 0 === e ? {} : e;
            const s = z(),
                a = r(),
                i = a.navigator.platform,
                n = t || a.navigator.userAgent,
                l = {
                    ios: !1,
                    android: !1
                },
                o = a.screen.width,
                d = a.screen.height,
                c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
            let p = n.match(/(iPad).*OS\s([\d_]+)/);
            const u = n.match(/(iPod)(.*OS\s([\d_]+))?/),
                m = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                h = "Win32" === i;
            let f = "MacIntel" === i;
            return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !h && (l.os = "android", l.android = !0), (p || m || u) && (l.os = "ios", l.ios = !0), l;
        }(e)), L;
    }

    function $() {
        return I || (I = function() {
            const e = r(),
                t = A();
            let s = !1;

            function a() {
                const t = e.navigator.userAgent.toLowerCase();
                return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0;
            }
            if (a()) {
                const t = String(e.navigator.userAgent);
                if (t.includes("Version/")) {
                    const [e, a] = t.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e)));
                    s = e < 16 || 16 === e && a < 2;
                }
            }
            const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent),
                n = a();
            return {
                isSafari: s || n,
                needPerspectiveFix: s,
                need3dFix: n || i && t.ios,
                isWebView: i
            };
        }()), I;
    }

    var k = {
        on(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;
            const i = s ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t);
            })), a;
        },
        once(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;

            function i() {
                a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;
                for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
                t.apply(a, r);
            }
            return i.__emitterProxy = t, a.on(e, i, s);
        },
        onAny(e, t) {
            const s = this;
            if (!s.eventsListeners || s.destroyed) return s;
            if ("function" != typeof e) return s;
            const a = t ? "unshift" : "push";
            return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s;
        },
        offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed) return t;
            if (!t.eventsAnyListeners) return t;
            const s = t.eventsAnyListeners.indexOf(e);
            return s >= 0 && t.eventsAnyListeners.splice(s, 1), t;
        },
        off(e, t) {
            const s = this;
            return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => {
                    (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1);
                }));
            })), s) : s;
        },
        emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let t, s, a;
            for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];
            "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);
            return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                    e.apply(a, [t, ...s]);
                })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                    e.apply(a, s);
                }));
            })), e;
        }
    };

    const O = (e, t, s) => {
        t && !e.classList.contains(s) ? e.classList.add(s) : !t && e.classList.contains(s) && e.classList.remove(s);
    };

    const D = (e, t, s) => {
        t && !e.classList.contains(s) ? e.classList.add(s) : !t && e.classList.contains(s) && e.classList.remove(s);
    };

    const G = (e, t) => {
        if (!e || e.destroyed || !e.params) return;
        const s = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
        if (s) {
            let t = s.querySelector(`.${e.params.lazyPreloaderClass}`);
            !t && e.isElement && (s.shadowRoot ? t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame((() => {
                s.shadowRoot && (t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove());
            }))), t && t.remove();
        }
    };

    const X = (e, t) => {
        if (!e.slides[t]) return;
        const s = e.slides[t].querySelector('[loading="lazy"]');
        s && s.removeAttribute("loading");
    };

    const Y = e => {
        if (!e || e.destroyed || !e.params) return;
        let t = e.params.lazyPreloadPrevNext;
        const s = e.slides.length;
        if (!s || !t || t < 0) return;
        t = Math.min(t, s);
        const a = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView),
            i = e.activeIndex;
        if (e.params.grid && e.params.grid.rows > 1) {
            const s = i,
                r = [s - t];
            return r.push(...Array.from({
                length: t
            }).map(((e, t) => s + a + t))), void e.slides.forEach(((t, s) => {
                r.includes(t.column) && X(e, s);
            }));
        }
        const r = i + a - 1;
        if (e.params.rewind || e.params.loop)
            for (let a = i - t; a <= r + t; a += 1) {
                const t = (a % s + s) % s;
                (t < i || t > r) && X(e, t);
            } else
                for (let a = Math.max(i - t, 0); a <= Math.min(r + t, s - 1); a += 1) a !== i && (a > r || a < i) && X(e, a);
    };

    var B = {
        updateSize: function() {
            const e = this;
            let t, s;
            const a = e.el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(b(a, "padding-left") || 0, 10) - parseInt(b(a, "padding-right") || 0, 10), s = s - parseInt(b(a, "padding-top") || 0, 10) - parseInt(b(a, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
                width: t,
                height: s,
                size: e.isHorizontal() ? t : s
            }));
        },
        updateSlides: function() {
            const e = this;

            function t(t, s) {
                return parseFloat(t.getPropertyValue(e.getDirectionLabel(s)) || 0);
            }
            const s = e.params, {
                    wrapperEl: a,
                    slidesEl: i,
                    size: r,
                    rtlTranslate: n,
                    wrongRTL: l
                } = e,
                o = e.virtual && s.virtual.enabled,
                d = o ? e.virtual.slides.length : e.slides.length,
                c = f(i, `.${e.params.slideClass}, swiper-slide`),
                p = o ? e.virtual.slides.length : c.length;
            let m = [];
            const h = [],
                g = [];
            let v = s.slidesOffsetBefore;
            "function" == typeof v && (v = s.slidesOffsetBefore.call(e));
            let w = s.slidesOffsetAfter;
            "function" == typeof w && (w = s.slidesOffsetAfter.call(e));
            const y = e.snapGrid.length,
                E = e.slidesGrid.length;
            let x = s.spaceBetween,
                T = -v,
                M = 0,
                C = 0;
            if (void 0 === r) return;
            "string" == typeof x && x.indexOf("%") >= 0 ? x = parseFloat(x.replace("%", "")) / 100 * r : "string" == typeof x && (x = parseFloat(x)), e.virtualSize = -x, c.forEach((e => {
                n ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "";
            })), s.centeredSlides && s.cssMode && (u(a, "--swiper-centered-offset-before", ""), u(a, "--swiper-centered-offset-after", ""));
            const P = s.grid && s.grid.rows > 1 && e.grid;
            let L;
            P ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides();
            const I = "auto" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter((e => void 0 !== s.breakpoints[e].slidesPerView)).length > 0;
            for (let a = 0; a < p; a += 1) {
                let i;
                if (L = 0, c[a] && (i = c[a]), P && e.grid.updateSlide(a, i, c), !c[a] || "none" !== b(i, "display")) {
                    if ("auto" === s.slidesPerView) {
                        I && (c[a].style[e.getDirectionLabel("width")] = "");
                        const r = getComputedStyle(i),
                            n = i.style.transform,
                            l = i.style.webkitTransform;
                        if (n && (i.style.transform = "none"), l && (i.style.webkitTransform = "none"), s.roundLengths) L = e.isHorizontal() ? S(i, "width", !0) : S(i, "height", !0);
                        else {
                            const e = t(r, "width"),
                                s = t(r, "padding-left"),
                                a = t(r, "padding-right"),
                                n = t(r, "margin-left"),
                                l = t(r, "margin-right"),
                                o = r.getPropertyValue("box-sizing");
                            if (o && "border-box" === o) L = e + n + l;
                            else {
                                const {
                                    clientWidth: t,
                                    offsetWidth: r
                                } = i;
                                L = e + s + a + n + l + (r - t);
                            }
                        }
                        n && (i.style.transform = n), l && (i.style.webkitTransform = l), s.roundLengths && (L = Math.floor(L));
                    } else L = (r - (s.slidesPerView - 1) * x) / s.slidesPerView, s.roundLengths && (L = Math.floor(L)), c[a] && (c[a].style[e.getDirectionLabel("width")] = `${L}px`);
                    c[a] && (c[a].swiperSlideSize = L), g.push(L), s.centeredSlides ? (T = T + L / 2 + M / 2 + x, 0 === M && 0 !== a && (T = T - r / 2 - x), 0 === a && (T = T - r / 2 - x), Math.abs(T) < .001 && (T = 0), s.roundLengths && (T = Math.floor(T)), C % s.slidesPerGroup == 0 && m.push(T), h.push(T)) : (s.roundLengths && (T = Math.floor(T)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && m.push(T), h.push(T), T = T + L + x), e.virtualSize += L + x, M = L, C += 1;
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, r) + w, n && l && ("slide" === s.effect || "coverflow" === s.effect) && (a.style.width = `${e.virtualSize+x}px`), s.setWrapperSize && (a.style[e.getDirectionLabel("width")] = `${e.virtualSize+x}px`), P && e.grid.updateWrapperSize(L, m), !s.centeredSlides) {
                const t = [];
                for (let a = 0; a < m.length; a += 1) {
                    let i = m[a];
                    s.roundLengths && (i = Math.floor(i)), m[a] <= e.virtualSize - r && t.push(i);
                }
                m = t, Math.floor(e.virtualSize - r) - Math.floor(m[m.length - 1]) > 1 && m.push(e.virtualSize - r);
            }
            if (o && s.loop) {
                const t = g[0] + x;
                if (s.slidesPerGroup > 1) {
                    const a = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / s.slidesPerGroup),
                        i = t * s.slidesPerGroup;
                    for (let e = 0; e < a; e += 1) m.push(m[m.length - 1] + i);
                }
                for (let a = 0; a < e.virtual.slidesBefore + e.virtual.slidesAfter; a += 1) 1 === s.slidesPerGroup && m.push(m[m.length - 1] + t), h.push(h[h.length - 1] + t), e.virtualSize += t;
            }
            if (0 === m.length && (m = [0]), 0 !== x) {
                const t = e.isHorizontal() && n ? "marginLeft" : e.getDirectionLabel("marginRight");
                c.filter(((e, t) => !(s.cssMode && !s.loop) || t !== c.length - 1)).forEach((e => {
                    e.style[t] = `${x}px`;
                }));
            }
            if (s.centeredSlides && s.centeredSlidesBounds) {
                let e = 0;
                g.forEach((t => {
                    e += t + (x || 0);
                })), e -= x;
                const t = e > r ? e - r : 0;
                m = m.map((e => e <= 0 ? -v : e > t ? t + w : e));
            }
            if (s.centerInsufficientSlides) {
                let e = 0;
                g.forEach((t => {
                    e += t + (x || 0);
                })), e -= x;
                const t = (s.slidesOffsetBefore || 0) + (s.slidesOffsetAfter || 0);
                if (e + t < r) {
                    const s = (r - e - t) / 2;
                    m.forEach(((e, t) => {
                        m[t] = e - s;
                    })), h.forEach(((e, t) => {
                        h[t] = e + s;
                    }));
                }
            }
            Object.assign(e, {
                slides: c,
                snapGrid: m,
                slidesGrid: h,
                slidesSizesGrid: g
            }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds && (u(a, "--swiper-centered-offset-before", -m[0] + "px"), u(a, "--swiper-centered-offset-after", e.size / 2 - g[g.length - 1] / 2 + "px");
            const t = -e.snapGrid[0],
                s = -e.slidesGrid[0];
            e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s));
        }), p !== d && e.emit("slidesLengthChange"), m.length !== y && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== E && e.emit("slidesGridLengthChange"), s.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !(o || s.cssMode || "slide" !== s.effect && "fade" !== s.effect)) {
            const t = `${s.containerModifierClass}backface-hidden`,
                a = e.el.classList.contains(t);
            p <= s.maxBackfaceHiddenSlides ? a || e.el.classList.add(t) : a && e.el.classList.remove(t);
        }
    },
    updateAutoHeight: function(e) {
        const t = this,
            s = [],
            a = t.virtual && t.params.virtual.enabled;
        let i, r = 0;
        "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
        const n = e => a ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
        if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
            if (t.params.centeredSlides)(t.visibleSlides || []).forEach((e => {
                s.push(e);
            }));
            else
                for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                    const e = t.activeIndex + i;
                    if (e > t.slides.length && !a) break;
                    s.push(n(e));
                }
        else s.push(n(t.activeIndex));
        for (i = 0; i < s.length; i += 1)
            if (void 0 !== s[i]) {
                const e = s[i].offsetHeight;
                r = e > r ? e : r;
            }(r || 0 === r) && (t.wrapperEl.style.height = `${r}px`);
    },
    updateSlidesOffset: function() {
        const e = this,
            t = e.slides,
            s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
        for (let a = 0; a < t.length; a += 1) t[a].swiperSlideOffset = (e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop) - s - e.cssOverflowAdjustment();
    },
    updateSlidesProgress: function(e) {
        void 0 === e && (e = this && this.translate || 0);
        const t = this,
            s = t.params, {
                slides: a,
                rtlTranslate: i,
                snapGrid: r
            } = t;
        if (0 === a.length) return;
        void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
        let n = -e;
        i && (n = e), t.visibleSlidesIndexes = [], t.visibleSlides = [];
        let l = s.spaceBetween;
        "string" == typeof l && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * t.size : "string" == typeof l && (l = parseFloat(l));
        for (let e = 0; e < a.length; e += 1) {
            const o = a[e];
            let d = o.swiperSlideOffset;
            s.cssMode && s.centeredSlides && (d -= a[0].swiperSlideOffset);
            const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l),
                p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l),
                u = -(n - d),
                m = u + t.slidesSizesGrid[e],
                h = u >= 0 && u <= t.size - t.slidesSizesGrid[e],
                f = u >= 0 && u < t.size - 1 || m > 1 && m <= t.size || u <= 0 && m >= t.size;
            f && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e)), O(o, f, s.slideVisibleClass), O(o, h, s.slideFullyVisibleClass), o.progress = i ? -c : c, o.originalProgress = i ? -p : p;
        }
    },
    updateProgress: function(e) {
        const t = this;
        if (void 0 === e) {
            const s = t.rtlTranslate ? -1 : 1;
            e = t && t.translate && t.translate * s || 0;
        }
        const s = t.params,
            a = t.maxTranslate() - t.minTranslate();
        let {
            progress: i,
            isBeginning: r,
            isEnd: n,
            progressLoop: l
        } = t;
        const o = r,
            d = n;
        if (0 === a) i = 0, r = !0, n = !0;
        else {
            i = (e - t.minTranslate()) / a;
            const s = Math.abs(e - t.minTranslate()) < 1,
                l = Math.abs(e - t.maxTranslate()) < 1;
            r = s || i <= 0, n = l || i >= 1, s && (i = 0), l && (i = 1);
        }
        if (s.loop) {
            const s = t.getSlideIndexByData(0),
                a = t.getSlideIndexByData(t.slides.length - 1),
                i = t.slidesGrid[s],
                r = t.slidesGrid[a],
                n = t.slidesGrid[t.slidesGrid.length - 1],
                o = Math.abs(e);
            l = o >= i ? (o - i) / n : (o + n - r) / n, l > 1 && (l -= 1);
        }
        Object.assign(t, {
            progress: i,
            progressLoop: l,
            isBeginning: r,
            isEnd: n
        }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !o && t.emit("reachBeginning toEdge"), n && !d && t.emit("reachEnd toEdge"), (o && !r || d && !n) && t.emit("fromEdge"), t.emit("progress", i);
    },
    updateSlidesClasses: function() {
        const e = this, {
                slides: t,
                params: s,
                slidesEl: a,
                activeIndex: i
            } = e,
            r = e.virtual && s.virtual.enabled,
            n = e.grid && s.grid && s.grid.rows > 1,
            l = e => f(a, `.${s.slideClass}${e}, swiper-slide${e}`)[0];
        let o, d, c;
        if (r)
            if (s.loop) {
                let t = i - e.virtual.slidesBefore;
                t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = l(`[data-swiper-slide-index="${t}"]`);
            } else o = l(`[data-swiper-slide-index="${i}"]`);
        else n ? (o = t.find((e => e.column === i)), c = t.find((e => e.column === i + 1)), d = t.find((e => e.column === i - 1))) : o = t[i];
        o && (n || (c = function(e, t) {
            const s = [];
            for (; e.nextElementSibling;) {
                const a = e.nextElementSibling;
                t ? a.matches(t) && s.push(a) : s.push(a), e = a;
            }
            return s;
        }(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && !c && (c = t[0]), d = function(e, t) {
            const s = [];
            for (; e.previousElementSibling;) {
                const a = e.previousElementSibling;
                t ? a.matches(t) && s.push(a) : s.push(a), e = a;
            }
            return s;
        }(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && 0 === !d && (d = t[t.length - 1]))), t.forEach((e => {
            D(e, e === o, s.slideActiveClass), D(e, e === c, s.slideNextClass), D(e, e === d, s.slidePrevClass);
        })), e.emitSlidesClasses();
    },
    updateActiveIndex: function(e) {
        const t = this,
            s = t.rtlTranslate ? t.translate : -t.translate, {
                snapGrid: a,
                params: i,
                activeIndex: r,
                realIndex: n,
                snapIndex: l
            } = t;
        let o, d = e;
        const c = e => {
            let s = e - t.virtual.slidesBefore;
            return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s;
        };
        if (void 0 === d && (d = function(e) {
                const {
                    slidesGrid: t,
                    params: s
                } = e, a = e.rtlTranslate ? e.translate : -e.translate;
                let i;
                for (let e = 0; e < t.length; e += 1) void 0 !== t[e + 1] ? a >= t[e] && a < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : a >= t[e] && a < t[e + 1] && (i = e + 1) : a >= t[e] && (i = e);
                return s.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0), i;
            }(t)), a.indexOf(s) >= 0) o = a.indexOf(s);
        else {
            const e = Math.min(i.slidesPerGroupSkip, d);
            o = e + Math.floor((d - e) / i.slidesPerGroup);
        }
        if (o >= a.length && (o = a.length - 1), d === r && !t.params.loop) return void(o !== l && (t.snapIndex = o, t.emit("snapIndexChange")));
        if (d === r && t.params.loop && t.virtual && t.params.virtual.enabled) return void(t.realIndex = c(d));
        const p = t.grid && i.grid && i.grid.rows > 1;
        let u;
        if (t.virtual && i.virtual.enabled && i.loop) u = c(d);
        else if (p) {
            const e = t.slides.find((e => e.column === d));
            let s = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
            Number.isNaN(s) && (s = Math.max(t.slides.indexOf(e), 0)), u = Math.floor(s / i.grid.rows);
        } else if (t.slides[d]) {
            const e = t.slides[d].getAttribute("data-swiper-slide-index");
            u = e ? parseInt(e, 10) : d;
        } else u = d;
        Object.assign(t, {
            previousSnapIndex: l,
            snapIndex: o,
            previousRealIndex: n,
            realIndex: u,
            previousIndex: r,
            activeIndex: d
        }), t.initialized && Y(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (n !== u && t.emit("realIndexChange"), t.emit("slideChange"));
    },
    updateClickedSlide: function(e, t) {
        const s = this,
            a = s.params;
        let i = e.closest(`.${a.slideClass}, swiper-slide`);
        !i && s.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach((e => {
            !i && e.matches && e.matches(`.${a.slideClass}, swiper-slide`) && (i = e);
        }));
        let r, n = !1;
        if (i)
            for (let e = 0; e < s.slides.length; e += 1)
                if (s.slides[e] === i) {
                    n = !0, r = e;
                    break;
                }
        if (!i || !n) return s.clickedSlide = void 0, void(s.clickedIndex = void 0);
        s.clickedSlide = i, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : s.clickedIndex = r, a.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide();
    }
};

var H = {
    getTranslate: function(e) {
        void 0 === e && (e = this.isHorizontal() ? "x" : "y");
        const {
            params: t,
            rtlTranslate: s,
            translate: a,
            wrapperEl: i
        } = this;
        if (t.virtualTranslate) return s ? -a : a;
        if (t.cssMode) return a;
        let r = d(i, e);
        return r += this.cssOverflowAdjustment(), s && (r = -r), r || 0;
    },
    setTranslate: function(e, t) {
        const s = this, {
                rtlTranslate: a,
                params: i,
                wrapperEl: r,
                progress: n
            } = s;
        let l, o = 0,
            d = 0;
        s.isHorizontal() ? o = a ? -e : e : d = e, i.roundLengths && (o = Math.floor(o), d = Math.floor(d)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? o : d, i.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -o : -d : i.virtualTranslate || (s.isHorizontal() ? o -= s.cssOverflowAdjustment() : d -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${o}px, ${d}px, 0px)`);
        const c = s.maxTranslate() - s.minTranslate();
        l = 0 === c ? 0 : (e - s.minTranslate()) / c, l !== n && s.updateProgress(e), s.emit("setTranslate", s.translate, t);
    },
    minTranslate: function() {
        return -this.snapGrid[0];
    },
    maxTranslate: function() {
        return -this.snapGrid[this.snapGrid.length - 1];
    },
    translateTo: function(e, t, s, a, i) {
        void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);
        const r = this, {
                params: n,
                wrapperEl: l
            } = r;
        if (r.animating && n.preventInteractionOnTransition) return !1;
        const o = r.minTranslate(),
            d = r.maxTranslate();
        let c;
        if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
            const e = r.isHorizontal();
            if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c;
            else {
                if (!r.support.smoothScroll) return m({
                    swiper: r,
                    targetPosition: -c,
                    side: e ? "left" : "top"
                }), !0;
                l.scrollTo({
                    [e ? "left" : "top"]: -c,
                    behavior: "smooth"
                });
            }
            return !0;
        }
        return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(e) {
            r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, s && r.emit("transitionEnd"));
        }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0;
    }
};

function N(e) {
    let {
        swiper: t,
        runCallbacks: s,
        direction: a,
        step: i
    } = e;
    const {
        activeIndex: r,
        previousIndex: n
    } = t;
    let l = a;
    l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && "reset" === l ? t.emit(`slideResetTransition${i}`) : s && r !== n && (t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`));
}

var R = {
    slideTo: function(e, t, s, a, i) {
        void 0 === e && (e = 0), void 0 === s && (s = !0), "string" == typeof e && (e = parseInt(e, 10));
        const r = this;
        let n = e;
        n < 0 && (n = 0);
        const {
                params: l,
                snapGrid: o,
                slidesGrid: d,
                previousIndex: c,
                activeIndex: p,
                rtlTranslate: u,
                wrapperEl: h,
                enabled: f
            } = r;
        if (!f && !a && !i || r.destroyed || r.animating && l.preventInteractionOnTransition) return !1;
        void 0 === t && (t = r.params.speed);
        const g = Math.min(r.params.slidesPerGroupSkip, n);
        let v = g + Math.floor((n - g) / r.params.slidesPerGroup);
        v >= o.length && (v = o.length - 1);
        const w = -o[v];
        if (l.normalizeSlideIndex)
            for (let e = 0; e < d.length; e += 1) {
                const t = -Math.floor(100 * w),
                    s = Math.floor(100 * d[e]),
                    a = Math.floor(100 * d[e + 1]);
                void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e);
            }
        if (r.initialized && n !== p) {
            if (!r.allowSlideNext && (u ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate())) return !1;
            if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n) return !1;
        }
        let b;
        n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(w), b = n > p ? "next" : n < p ? "prev" : "reset";
        const y = r.virtual && r.params.virtual.enabled;
        if (!(y && i) && (u && -w === r.translate || !u && w === r.translate)) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(w), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
        if (l.cssMode) {
            const e = r.isHorizontal(),
                s = u ? w : -w;
            if (0 === t) y && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), y && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => {
                h[e ? "scrollLeft" : "scrollTop"] = s;
            }))) : h[e ? "scrollLeft" : "scrollTop"] = s, y && requestAnimationFrame((() => {
                r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1;
            }));
            else {
                if (!r.support.smoothScroll) return m({
                    swiper: r,
                    targetPosition: s,
                    side: e ? "left" : "top"
                }), !0;
                h.scrollTo({
                    [e ? "left" : "top"]: s,
                    behavior: "smooth"
                });
            }
            return !0;
        }
        const E = $().isSafari;
        return y && !i && E && r.isElement && r.virtual.update(!1, !1, n), r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) {
            r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b));
        }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0;
    },
    slideToLoop: function(e, t, s, a) {
        if (void 0 === e && (e = 0), void 0 === s && (s = !0), "string" == typeof e) {
            e = parseInt(e, 10);
        }
        const i = this;
        if (i.destroyed) return;
        void 0 === t && (t = i.params.speed);
        const r = i.grid && i.params.grid && i.params.grid.rows > 1;
        let n = e;
        if (i.params.loop)
            if (i.virtual && i.params.virtual.enabled) n += i.virtual.slidesBefore;
            else {
                let e;
                if (r) {
                    const t = n * i.params.grid.rows;
                    e = i.slides.find((e => 1 * e.getAttribute("data-swiper-slide-index") === t)).column;
                } else e = i.getSlideIndexByData(n);
                const t = r ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length, {
                        centeredSlides: s
                    } = i.params;
                let l = i.params.slidesPerView;
                "auto" === l ? l = i.slidesPerViewDynamic() : (l = Math.ceil(parseFloat(i.params.slidesPerView, 10)), s && l % 2 == 0 && (l += 1));
                let o = t - e < l;
                if (s && (o = o || e < Math.ceil(l / 2)), a && s && "auto" !== i.params.slidesPerView && !r && (o = !1), o) {
                    const a = s ? e < i.activeIndex ? "prev" : "next" : e - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev";
                    i.loopFix({
                        direction: a,
                        slideTo: !0,
                        activeSlideIndex: "next" === a ? e + 1 : e - t + 1,
                        slideRealIndex: "next" === a ? i.realIndex : void 0
                    });
                }
                if (r) {
                    const e = n * i.params.grid.rows;
                    n = i.slides.find((t => 1 * t.getAttribute("data-swiper-slide-index") === e)).column;
                } else n = i.getSlideIndexByData(n);
            }
        return requestAnimationFrame((() => {
            i.slideTo(n, t, s, a);
        })), i;
    },
    slideNext: function(e, t, s) {
        void 0 === t && (t = !0);
        const a = this, {
                enabled: i,
                params: r,
                animating: n
            } = a;
        if (!i || a.destroyed) return a;
        void 0 === e && (e = a.params.speed);
        let l = r.slidesPerGroup;
        "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
        const o = a.activeIndex < r.slidesPerGroupSkip ? 1 : l,
            d = a.virtual && r.virtual.enabled;
        if (r.loop) {
            if (n && !d && r.loopPreventsSliding) return !1;
            if (a.loopFix({
                    direction: "next"
                }), a._clientLeft = a.wrapperEl.clientLeft, a.activeIndex === a.slides.length - 1 && r.cssMode) return requestAnimationFrame((() => {
                a.slideTo(a.activeIndex + o, e, t, s);
            })), !0;
        }
        return r.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s);
    },
    slidePrev: function(e, t, s) {
        void 0 === t && (t = !0);
        const a = this, {
                params: i,
                snapGrid: r,
                slidesGrid: n,
                rtlTranslate: l,
                enabled: o,
                animating: d
            } = a;
        if (!o || a.destroyed) return a;
        void 0 === e && (e = a.params.speed);
        const c = a.virtual && i.virtual.enabled;
        if (i.loop) {
            if (d && !c && i.loopPreventsSliding) return !1;
            a.loopFix({
                direction: "prev"
            }), a._clientLeft = a.wrapperEl.clientLeft;
        }

        function p(e) {
            return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);
        }
        const u = p(l ? a.translate : -a.translate),
            m = r.map((e => p(e))),
            h = i.freeMode && i.freeMode.enabled;
        let f = r[m.indexOf(u) - 1];
        if (void 0 === f && (i.cssMode || h)) {
            let e;
            r.forEach(((t, s) => {
                u >= t && (e = s);
            })), void 0 !== e && (f = h ? r[e] : r[e > 0 ? e - 1 : e]);
        }
        let g = 0;
        if (void 0 !== f && (g = n.indexOf(f), g < 0 && (g = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (g = g - a.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), i.rewind && a.isBeginning) {
            const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
            return a.slideTo(i, e, t, s);
        }
        return i.loop && 0 === a.activeIndex && i.cssMode ? (requestAnimationFrame((() => {
            a.slideTo(g, e, t, s);
        })), !0) : a.slideTo(g, e, t, s);
    },
    slideReset: function(e, t, s) {
        void 0 === t && (t = !0);
        const a = this;
        if (!a.destroyed) return void 0 === e && (e = a.params.speed), a.slideTo(a.activeIndex, e, t, s);
    },
    slideToClosest: function(e, t, s, a) {
        void 0 === t && (t = !0), void 0 === a && (a = .5);
        const i = this;
        if (i.destroyed) return;
        void 0 === e && (e = i.params.speed);
        let r = i.activeIndex;
        const n = Math.min(i.params.slidesPerGroupSkip, r),
            l = n + Math.floor((r - n) / i.params.slidesPerGroup),
            o = i.rtlTranslate ? i.translate : -i.translate;
        if (o >= i.snapGrid[l]) {
            const e = i.snapGrid[l];
            o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup);
        } else {
            const e = i.snapGrid[l - 1];
            o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup);
        }
        return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s);
    },
    slideToClickedSlide: function() {
        const e = this;
        if (e.destroyed) return;
        const {
                params: t,
                slidesEl: s
            } = e,
            a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
        let i, r = e.getSlideIndexWhenGrid(e.clickedIndex);
        const n = e.isElement ? "swiper-slide" : `.${t.slideClass}`,
            o = e.grid && e.params.grid && e.params.grid.rows > 1;
        if (t.loop) {
            if (e.animating) return;
            i = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? e.slideToLoop(i) : r > (o ? (e.slides.length - a) / 2 - (e.params.grid.rows - 1) : e.slides.length - a) ? (e.loopFix(), r = e.getSlideIndex(f(s, `${n}[data-swiper-slide-index="${i}"]`)[0]), l((() => {
                e.slideTo(r);
            }))) : e.slideTo(r);
        } else e.slideTo(r);
    }
};

var _ = {
    loopCreate: function(e, t) {
        const s = this, {
                params: a,
                slidesEl: i
            } = s;
        if (!a.loop || s.virtual && s.params.virtual.enabled) return;
        const r = () => {
            f(i, `.${a.slideClass}, swiper-slide`).forEach(((e, t) => {
                e.setAttribute("data-swiper-slide-index", t);
            }));
        }, n = s.grid && a.grid && a.grid.rows > 1;
        a.loopAddBlankSlides && (a.slidesPerGroup > 1 || n) && (() => {
            const e = f(i, `.${a.slideBlankClass}`);
            e.forEach((e => {
                e.remove();
            })), e.length > 0 && (s.recalcSlides(), s.updateSlides());
        })();
        const l = a.slidesPerGroup * (n ? a.grid.rows : 1),
            o = s.slides.length % l != 0,
            d = n && s.slides.length % a.grid.rows != 0,
            c = e => {
                for (let t = 0; t < e; t += 1) {
                    const e = s.isElement ? v("swiper-slide", [a.slideBlankClass]) : v("div", [a.slideClass, a.slideBlankClass]);
                    s.slidesEl.append(e);
                }
            };
        if (o) {
            if (a.loopAddBlankSlides) {
                c(l - s.slides.length % l), s.recalcSlides(), s.updateSlides();
            } else g("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
            r();
        } else if (d) {
            if (a.loopAddBlankSlides) {
                c(a.grid.rows - s.slides.length % a.grid.rows), s.recalcSlides(), s.updateSlides();
            } else g("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
            r();
        } else r();
        s.loopFix({
            slideRealIndex: e,
            direction: a.centeredSlides ? void 0 : "next",
            initial: t
        });
    },
    loopFix: function(e) {
        let {
            slideRealIndex: t,
            slideTo: s = !0,
            direction: a,
            setTranslate: i,
            activeSlideIndex: r,
            initial: n,
            byController: l,
            byMousewheel: o
        } = void 0 === e ? {} : e;
        const d = this;
        if (!d.params.loop) return;
        d.emit("beforeLoopFix");
        const {
                slides: c,
                allowSlidePrev: p,
                allowSlideNext: u,
                slidesEl: m,
                params: h
            } = d, {
                centeredSlides: f,
                initialSlide: v
            } = h;
        if (d.allowSlidePrev = !0, d.allowSlideNext = !0, d.virtual && h.virtual.enabled) return s && (h.centeredSlides || 0 !== d.snapIndex ? h.centeredSlides && d.snapIndex < h.slidesPerView ? d.slideTo(d.virtual.slides.length + d.snapIndex, 0, !1, !0) : d.snapIndex === d.snapGrid.length - 1 && d.slideTo(d.virtual.slidesBefore, 0, !1, !0) : d.slideTo(d.virtual.slides.length, 0, !1, !0)), d.allowSlidePrev = p, d.allowSlideNext = u, void d.emit("loopFix");
        let w = h.slidesPerView;
        "auto" === w ? w = d.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(h.slidesPerView, 10)), f && w % 2 == 0 && (w += 1));
        const b = h.slidesPerGroupAuto ? w : h.slidesPerGroup;
        let y = f ? Math.max(b, Math.ceil(w / 2)) : b;
        y % b != 0 && (y += b - y % b), y += h.loopAdditionalSlides, d.loopedSlides = y;
        const E = d.grid && h.grid && h.grid.rows > 1;
        c.length < w + y || "cards" === d.params.effect && c.length < w + 2 * y ? g("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : E && "row" === h.grid.fill && g("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
        const x = [],
            S = [],
            T = E ? Math.ceil(c.length / h.grid.rows) : c.length,
            M = n && T - v < w && !f;
        let C = M ? v : d.activeIndex;
        void 0 === r ? r = d.getSlideIndex(c.find((e => e.classList.contains(h.slideActiveClass)))) : C = r;
        const P = "next" === a || !a,
            L = "prev" === a || !a;
        let I = 0,
            z = 0;
        const A = (E ? c[r].column : r) + (f && void 0 === i ? -w / 2 + .5 : 0);
        if (A < y) {
            I = Math.max(y - A, b);
            for (let e = 0; e < y - A; e += 1) {
                const t = e - Math.floor(e / T) * T;
                if (E) {
                    const e = T - t - 1;
                    for (let t = c.length - 1; t >= 0; t -= 1) c[t].column === e && x.push(t);
                } else x.push(T - t - 1);
            }
        } else if (A + w > T - y) {
            z = Math.max(A - (T - 2 * y), b), M && (z = Math.max(z, w - T + v + 1));
            for (let e = 0; e < z; e += 1) {
                const t = e - Math.floor(e / T) * T;
                E ? c.forEach(((e, s) => {
                    e.column === t && S.push(s);
                })) : S.push(t);
            }
        }
        if (d.__preventObserver__ = !0, requestAnimationFrame((() => {
                d.__preventObserver__ = !1;
            })), "cards" === d.params.effect && c.length < w + 2 * y && (S.includes(r) && S.splice(S.indexOf(r), 1), x.includes(r) && x.splice(x.indexOf(r), 1)), L && x.forEach((e => {
                c[e].swiperLoopMoveDOM = !0, m.prepend(c[e]), c[e].swiperLoopMoveDOM = !1;
            })), P && S.forEach((e => {
                c[e].swiperLoopMoveDOM = !0, m.append(c[e]), c[e].swiperLoopMoveDOM = !1;
            })), d.recalcSlides(), "auto" === h.slidesPerView ? d.updateSlides() : E && (x.length > 0 && L || S.length > 0 && P) && d.slides.forEach(((e, t) => {
                d.grid.updateSlide(t, e, d.slides);
            })), h.watchSlidesProgress && d.updateSlidesOffset(), s)
            if (x.length > 0 && L) {
                if (void 0 === t) {
                    const e = d.slidesGrid[C],
                        t = d.slidesGrid[C + I] - e;
                    o ? d.setTranslate(d.translate - t) : (d.slideTo(C + Math.ceil(I), 0, !1, !0), i && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - t, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - t));
                } else if (i) {
                    const e = E ? x.length / h.grid.rows : x.length;
                    d.slideTo(d.activeIndex + e, 0, !1, !0), d.touchEventsData.currentTranslate = d.translate;
                }
            } else if (S.length > 0 && P)
                if (void 0 === t) {
                    const e = d.slidesGrid[C],
                        t = d.slidesGrid[C - z] - e;
                    o ? d.setTranslate(d.translate - t) : (d.slideTo(C - z, 0, !1, !0), i && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - t, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - t));
                } else {
                    const e = E ? S.length / h.grid.rows : S.length;
                    d.slideTo(d.activeIndex - e, 0, !1, !0);
                }
        if (d.allowSlidePrev = p, d.allowSlideNext = u, d.controller && d.controller.control && !l) {
            const e = {
                slideRealIndex: t,
                direction: a,
                setTranslate: i,
                activeSlideIndex: r,
                byController: !0
            };
            Array.isArray(d.controller.control) ? d.controller.control.forEach((t => {
                !t.destroyed && t.params.loop && t.loopFix({
                    ...e,
                    slideTo: t.params.slidesPerView === h.slidesPerView && s
                });
            })) : d.controller.control instanceof d.constructor && d.controller.control.params.loop && d.controller.control.loopFix({
                ...e,
                slideTo: d.controller.control.params.slidesPerView === h.slidesPerView && s
            });
        }
        d.emit("loopFix");
    },
    loopDestroy: function() {
        const e = this, {
                params: t,
                slidesEl: s
            } = e;
        if (!t.loop || !s || e.virtual && e.params.virtual.enabled) return;
        e.recalcSlides();
        const a = [];
        e.slides.forEach((e => {
            const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
            a[t] = e;
        })), e.slides.forEach((e => {
            e.removeAttribute("data-swiper-slide-index");
        })), a.forEach((e => {
            s.append(e);
        })), e.recalcSlides(), e.slideTo(e.realIndex, 0);
    }
};

function q(e, t, s) {
    const a = r(), {
            params: i
        } = e,
        n = i.edgeSwipeDetection,
        l = i.edgeSwipeThreshold;
    return !n || !(s <= l || s >= a.innerWidth - l) || "prevent" === n && (t.preventDefault(), !0);
}

function V(e) {
    const t = this,
        s = a();
    let i = e;
    i.originalEvent && (i = i.originalEvent);
    const n = t.touchEventsData;
    if ("pointerdown" === i.type) {
        if (null !== n.pointerId && n.pointerId !== i.pointerId) return;
        n.pointerId = i.pointerId;
    } else "touchstart" === i.type && 1 === i.targetTouches.length && (n.touchId = i.targetTouches[0].identifier);
    if ("touchstart" === i.type) return void q(t, i, i.targetTouches[0].pageX);
    const {
            params: l,
            touches: d,
            enabled: c
        } = t;
    if (!c) return;
    if (!l.simulateTouch && "mouse" === i.pointerType) return;
    if (t.animating && l.preventInteractionOnTransition) return;
    !t.animating && l.cssMode && l.loop && t.loopFix();
    let p = i.target;
    if ("wrapper" === l.touchEventsTarget && !function(e, t) {
            const s = r();
            let a = t.contains(e);
            !a && s.HTMLSlotElement && t instanceof HTMLSlotElement && (a = [...t.assignedElements()].includes(e), a || (a = function(e, t) {
                const s = [t];
                for (; s.length > 0;) {
                    const t = s.shift();
                    if (e === t) return !0;
                    s.push(...t.children, ...t.shadowRoot ? t.shadowRoot.children : [], ...t.assignedElements ? t.assignedElements() : []);
                }
            }(e, t)));
            return a;
        }(p, t.wrapperEl)) return;
    if ("which" in i && 3 === i.which) return;
    if ("button" in i && i.button > 0) return;
    if (n.isTouched && n.isMoved) return;
    const u = !!l.noSwipingClass && "" !== l.noSwipingClass,
        m = i.composedPath ? i.composedPath() : i.path;
    u && i.target && i.target.shadowRoot && m && (p = m[0]);
    const h = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
        f = !(!i.target || !i.target.shadowRoot);
    if (l.noSwiping && (f ? function(e, t) {
            return void 0 === t && (t = this), function t(s) {
                if (!s || s === a() || s === r()) return null;
                s.assignedSlot && (s = s.assignedSlot);
                const i = s.closest(e);
                return i || s.getRootNode ? i || t(s.getRootNode().host) : null;
            }(t);
        }(h, p) : p.closest(h))) return void(t.allowClick = !0);
    if (l.swipeHandler && !p.closest(l.swipeHandler)) return;
    d.currentX = i.pageX, d.currentY = i.pageY;
    const g = d.currentX,
        v = d.currentY;
    if (!q(t, i, g)) return;
    Object.assign(n, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }), d.startX = g, d.startY = v, n.touchStartTime = o(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1);
    let w = !0;
    p.matches(n.focusableElements) && (w = !1, "SELECT" === p.nodeName && (n.isTouched = !1)), s.activeElement && s.activeElement.matches(n.focusableElements) && s.activeElement !== p && ("mouse" === i.pointerType || "mouse" !== i.pointerType && !p.matches(n.focusableElements)) && s.activeElement.blur();
    const b = w && t.allowTouchMove && l.touchStartPreventDefault;
    !l.touchStartForcePreventDefault && !b || p.isContentEditable || i.preventDefault(), l.freeMode && l.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", i);
}

function F(e) {
    const t = a(),
        s = this,
        i = s.touchEventsData, {
            params: r,
            touches: n,
            rtlTranslate: l,
            enabled: d
        } = s;
    if (!d) return;
    if (!r.simulateTouch && "mouse" === e.pointerType) return;
    let c, p = e;
    if (p.originalEvent && (p = p.originalEvent), "pointermove" === p.type) {
        if (null !== i.touchId) return;
        if (p.pointerId !== i.pointerId) return;
    } else if ("touchmove" === p.type) {
        if (c = [...p.changedTouches].find((e => e.identifier === i.touchId)), !c || c.identifier !== i.touchId) return;
    } else c = p;
    if (!i.isTouched) return void(i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", p));
    const u = c.pageX,
        m = c.pageY;
    if (p.preventedByNestedSwiper) return n.startX = u, void(n.startY = m);
    if (!s.allowTouchMove) return p.target.matches(i.focusableElements) || (s.allowClick = !1), void(i.isTouched && (Object.assign(n, {
        startX: u,
        startY: m,
        currentX: u,
        currentY: m
    }), i.touchStartTime = o()));
    if (r.touchReleaseOnEdges && !r.loop)
        if (s.isVertical()) {
            if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1);
        } else {
            if (l && (u > n.startX && -s.translate <= s.maxTranslate() || u < n.startX && -s.translate >= s.minTranslate())) return;
            if (!l && (u < n.startX && s.translate <= s.maxTranslate() || u > n.startX && s.translate >= s.minTranslate())) return;
        }
    if (t.activeElement && t.activeElement.matches(i.focusableElements) && t.activeElement !== p.target && "mouse" !== p.pointerType && t.activeElement.blur(), t.activeElement && p.target === t.activeElement && p.target.matches(i.focusableElements)) return i.isMoved = !0, void(s.allowClick = !1);
    i.allowTouchCallbacks && s.emit("touchMove", p), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = u, n.currentY = m;
    const h = n.currentX - n.startX,
        f = n.currentY - n.startY;
    if (s.params.threshold && Math.sqrt(h ** 2 + f ** 2) < s.params.threshold) return;
    if (void 0 === i.isScrolling) {
        let e;
        s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : h * h + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(h)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle);
    }
    if (i.isScrolling && s.emit("touchMoveOpposite", p), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling || "touchmove" === p.type && i.preventTouchMoveFromPointerMove) return void(i.isTouched = !1);
    if (!i.startMoving) return;
    s.allowClick = !1, !r.cssMode && p.cancelable && p.preventDefault(), r.touchMoveStopPropagation && !r.nested && p.stopPropagation();
    let g = s.isHorizontal() ? h : f,
        v = s.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY;
    r.oneWayMovement && (g = Math.abs(g) * (l ? 1 : -1), v = Math.abs(v) * (l ? 1 : -1)), n.diff = g, g *= r.touchRatio, l && (g = -g, v = -v);
    const w = s.touchesDirection;
    s.swipeDirection = g > 0 ? "prev" : "next", s.touchesDirection = v > 0 ? "prev" : "next";
    const b = s.params.loop && !r.cssMode,
        y = "next" === s.touchesDirection && s.allowSlideNext || "prev" === s.touchesDirection && s.allowSlidePrev;
    if (!i.isMoved) {
        if (b && y && s.loopFix({
                direction: s.swipeDirection
            }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) {
            const e = new window.CustomEvent("transitionend", {
                bubbles: !0,
                cancelable: !0,
                detail: {
                    bySwiperTouchMove: !0
                }
            });
            s.wrapperEl.dispatchEvent(e);
        }
        i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", p);
    }
    if ((new Date).getTime(), !1 !== r._loopSwapReset && i.isMoved && i.allowThresholdMove && w !== s.touchesDirection && b && y && Math.abs(g) >= 1) return Object.assign(n, {
        startX: u,
        startY: m,
        currentX: u,
        currentY: m,
        startTranslate: i.currentTranslate
    }), i.loopSwapReset = !0, void(i.startTranslate = i.currentTranslate);
    s.emit("sliderMove", p), i.isMoved = !0, i.currentTranslate = g + i.startTranslate;
    let E = !0,
        x = r.resistanceRatio;
    if (r.touchReleaseOnEdges && (x = 0), g > 0 ? (b && y && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? s.minTranslate() - s.slidesSizesGrid[s.activeIndex + 1] - ("auto" !== r.slidesPerView && s.slides.length - r.slidesPerView >= 2 ? s.slidesSizesGrid[s.activeIndex + 1] + s.params.spaceBetween : 0) - s.params.spaceBetween : s.minTranslate()) && s.loopFix({
            direction: "prev",
            setTranslate: !0,
            activeSlideIndex: 0
        }), i.currentTranslate > s.minTranslate() && (E = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + g) ** x))) : g < 0 && (b && y && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? s.maxTranslate() + s.slidesSizesGrid[s.slidesSizesGrid.length - 1] + s.params.spaceBetween + ("auto" !== r.slidesPerView && s.slides.length - r.slidesPerView >= 2 ? s.slidesSizesGrid[s.slidesSizesGrid.length - 1] + s.params.spaceBetween : 0) : s.maxTranslate()) && s.loopFix({
            direction: "next",
            setTranslate: !0,
            activeSlideIndex: s.slides.length - ("auto" === r.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
        }), i.currentTranslate < s.maxTranslate() && (E = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - g) ** x))), E && (p.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
        if (!(Math.abs(g) > r.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
        if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void(n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY);
    }
    r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate));
}

function W(e) {
    const t = this,
        s = t.touchEventsData;
    let a, i = e;
    i.originalEvent && (i = i.originalEvent);
    if ("touchend" === i.type || "touchcancel" === i.type) {
        if (a = [...i.changedTouches].find((e => e.identifier === s.touchId)), !a || a.identifier !== s.touchId) return;
    } else {
        if (null !== s.touchId) return;
        if (i.pointerId !== s.pointerId) return;
        a = i;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type)) {
        if (!(["pointercancel", "contextmenu"].includes(i.type) && (t.browser.isSafari || t.browser.isWebView))) return;
    }
    s.pointerId = null, s.touchId = null;
    const {
            params: r,
            touches: n,
            rtlTranslate: d,
            slidesGrid: c,
            enabled: p
        } = t;
    if (!p) return;
    if (!r.simulateTouch && "mouse" === i.pointerType) return;
    if (s.allowTouchCallbacks && t.emit("touchEnd", i), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && r.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void(s.startMoving = !1);
    r.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
    const u = o(),
        m = u - s.touchStartTime;
    if (t.allowClick) {
        const e = i.path || i.composedPath && i.composedPath();
        t.updateClickedSlide(e && e[0] || i.target, e), t.emit("tap click", i), m < 300 && u - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", i);
    }
    if (s.lastClickTime = o(), l((() => {
            t.destroyed || (t.allowClick = !0);
        })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === n.diff && !s.loopSwapReset || s.currentTranslate === s.startTranslate && !s.loopSwapReset) return s.isTouched = !1, s.isMoved = !1, void(s.startMoving = !1);
    let h;
    if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = r.followFinger ? d ? t.translate : -t.translate : -s.currentTranslate, r.cssMode) return;
    if (r.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({
        currentPos: h
    });
    const f = h >= -t.maxTranslate() && !t.params.loop;
    let g = 0,
        v = t.slidesSizesGrid[0];
    for (let e = 0; e < c.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) {
        const t = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        void 0 !== c[e + t] ? (f || h >= c[e] && h < c[e + t]) && (g = e, v = c[e + t] - c[e]) : (f || h >= c[e]) && (g = e, v = c[c.length - 1] - c[c.length - 2]);
    }
    let w = null,
        b = null;
    r.rewind && (t.isBeginning ? b = r.virtual && r.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (w = 0));
    const y = (h - c[g]) / v,
        E = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
    if (m > r.longSwipesMs) {
        if (!r.longSwipes) return void t.slideTo(t.activeIndex);
        "next" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? w : g + E) : t.slideTo(g)), "prev" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(g + E) : null !== b && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(b) : t.slideTo(g));
    } else {
        if (!r.shortSwipes) return void t.slideTo(t.activeIndex);
        t.navigation && (i.target === t.navigation.nextEl || i.target === t.navigation.prevEl) ? i.target === t.navigation.nextEl ? t.slideTo(g + E) : t.slideTo(g) : ("next" === t.swipeDirection && t.slideTo(null !== w ? w : g + E), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g));
    }
}

function j() {
    const e = this, {
            params: t,
            el: s
        } = e;
    if (s && 0 === s.offsetWidth) return;
    t.breakpoints && e.setBreakpoint();
    const {
            allowSlideNext: a,
            allowSlidePrev: i,
            snapGrid: r
        } = e,
        n = e.virtual && e.params.virtual.enabled;
    e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
    const l = n && t.loop;
    ("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || l ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => {
        e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume();
    }), 500)), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow();
}

function U(e) {
    const t = this;
    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())));
}

function K() {
    const e = this, {
            wrapperEl: t,
            rtlTranslate: s,
            enabled: a
        } = e;
    if (!a) return;
    let i;
    e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
    const r = e.maxTranslate() - e.minTranslate();
    i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1);
}

function Z(e) {
    const t = this;
    G(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update();
}

function Q() {
    const e = this;
    e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"));
}

const J = (e, t) => {
    const s = a(), {
            params: i,
            el: r,
            wrapperEl: n,
            device: l
        } = e,
        o = !!i.nested,
        d = "on" === t ? "addEventListener" : "removeEventListener",
        c = t;
    r && "string" != typeof r && (s[d]("touchstart", e.onDocumentTouchStart, {
        passive: !1,
        capture: o
    }), r[d]("touchstart", e.onTouchStart, {
        passive: !1
    }), r[d]("pointerdown", e.onTouchStart, {
        passive: !1
    }), s[d]("touchmove", e.onTouchMove, {
        passive: !1,
        capture: o
    }), s[d]("pointermove", e.onTouchMove, {
        passive: !1,
        capture: o
    }), s[d]("touchend", e.onTouchEnd, {
        passive: !0
    }), s[d]("pointerup", e.onTouchEnd, {
        passive: !0
    }), s[d]("pointercancel", e.onTouchEnd, {
        passive: !0
    }), s[d]("pointerout", e.onTouchEnd, {
        passive: !0
    }), s[d]("pointerleave", e.onTouchEnd, {
        passive: !0
    }), s[d]("contextmenu", e.onTouchEnd, {
        passive: !0
    }), (i.preventClicks || i.preventClicksPropagation) && r[d]("click", e.onClick, !0), i.cssMode && n[d]("scroll", e.onScroll), i.updateOnWindowResize ? e[c](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", j, !0) : e[c]("observerUpdate", j, !0), r[d]("load", e.onLoad, {
        capture: !0
    }));
};

const ee = (e, t) => e.grid && t.grid && t.grid.rows > 1;

var te = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !0,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};

function se(e, t) {
    return function(s) {
        void 0 === s && (s = {});
        const a = Object.keys(s)[0],
            i = s[a];
        "object" == typeof i && null !== i ? (!0 === e[a] && (e[a] = {
            enabled: !0
        }), "navigation" === a && e[a] && e[a].enabled && !e[a].prevEl && !e[a].nextEl && (e[a].auto = !0), ["pagination", "scrollbar"].indexOf(a) >= 0 && e[a] && e[a].enabled && !e[a].el && (e[a].auto = !0), a in e && "enabled"in i ? ("object" != typeof e[a] || "enabled"in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {
            enabled: !1
        }), p(t, s)) : p(t, s)) : p(t, s);
    };
}

const ae = {
    eventsEmitter: k,
    update: B,
    translate: H,
    transition: {
        setTransition: function(e, t) {
            const s = this;
            s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`, s.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), s.emit("setTransition", e, t);
        },
        transitionStart: function(e, t) {
            void 0 === e && (e = !0);
            const s = this, {
                params: a
            } = s;
            a.cssMode || (a.autoHeight && s.updateAutoHeight(), N({
                swiper: s,
                runCallbacks: e,
                direction: t,
                step: "Start"
            }));
        },
        transitionEnd: function(e, t) {
            void 0 === e && (e = !0);
            const s = this, {
                params: a
            } = s;
            s.animating = !1, a.cssMode || (s.setTransition(0), N({
                swiper: s,
                runCallbacks: e,
                direction: t,
                step: "End"
            }));
        }
    },
    slide: R,
    loop: _,
    grabCursor: {
        setGrabCursor: function(e) {
            const t = this;
            if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
            const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
            t.isElement && (t.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => {
                t.__preventObserver__ = !1;
            }));
        },
        unsetGrabCursor: function() {
            const e = this;
            e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => {
                e.__preventObserver__ = !1;
            })));
        }
    },
    events: {
        attachEvents: function() {
            const e = this, {
                params: t
            } = e;
            e.onTouchStart = V.bind(e), e.onTouchMove = F.bind(e), e.onTouchEnd = W.bind(e), e.onDocumentTouchStart = Q.bind(e), t.cssMode && (e.onScroll = K.bind(e)), e.onClick = U.bind(e), e.onLoad = Z.bind(e), J(e, "on");
        },
        detachEvents: function() {
            J(this, "off");
        }
    },
    breakpoints: {
        setBreakpoint: function() {
            const e = this, {
                    realIndex: t,
                    initialized: s,
                    params: i,
                    el: r
                } = e,
                n = i.breakpoints;
            if (!n || n && 0 === Object.keys(n).length) return;
            const l = a(),
                o = "window" !== i.breakpointsBase && i.breakpointsBase ? "container" : i.breakpointsBase,
                d = ["window", "container"].includes(i.breakpointsBase) || !i.breakpointsBase ? e.el : l.querySelector(i.breakpointsBase),
                c = e.getBreakpoint(n, o, d);
            if (!c || e.currentBreakpoint === c) return;
            const u = (c in n ? n[c] : void 0) || e.originalParams,
                m = ee(e, i),
                h = ee(e, u),
                f = e.params.grabCursor,
                g = u.grabCursor,
                v = i.enabled;
            m && !h ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !m && h && (r.classList.add(`${i.containerModifierClass}grid`), (u.grid.fill && "column" === u.grid.fill || !u.grid.fill && "column" === i.grid.fill) && r.classList.add(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), f && !g ? e.unsetGrabCursor() : !f && g && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach((t => {
                if (void 0 === u[t]) return;
                const s = i[t] && i[t].enabled,
                    a = u[t] && u[t].enabled;
                s && !a && e[t].disable(), !s && a && e[t].enable();
            }));
            const w = u.direction && u.direction !== i.direction,
                b = i.loop && (u.slidesPerView !== i.slidesPerView || w),
                y = i.loop;
            w && s && e.changeDirection(), p(e.params, u);
            const E = e.params.enabled,
                x = e.params.loop;
            Object.assign(e, {
                allowTouchMove: e.params.allowTouchMove,
                allowSlideNext: e.params.allowSlideNext,
                allowSlidePrev: e.params.allowSlidePrev
            }), v && !E ? e.disable() : !v && E && e.enable(), e.currentBreakpoint = c, e.emit("_beforeBreakpoint", u), s && (b ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !y && x ? (e.loopCreate(t), e.updateSlides()) : y && !x && e.loopDestroy()), e.emit("breakpoint", u);
        },
        getBreakpoint: function(e, t, s) {
            if (void 0 === t && (t = "window"), !e || "container" === t && !s) return;
            let a = !1;
            const i = r(),
                n = "window" === t ? i.innerHeight : s.clientHeight,
                l = Object.keys(e).map((e => {
                    if ("string" == typeof e && 0 === e.indexOf("@")) {
                        const t = parseFloat(e.substr(1));
                        return {
                            value: n * t,
                            point: e
                        };
                    }
                    return {
                        value: e,
                        point: e
                    };
                }));
            l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
            for (let e = 0; e < l.length; e += 1) {
                const {
                    point: r,
                    value: n
                } = l[e];
                "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r);
            }
            return a || "max";
        }
    },
    checkOverflow: {
        checkOverflow: function() {
            const e = this, {
                isLocked: t,
                params: s
            } = e, {
                slidesOffsetBefore: a
            } = s;
            if (a) {
                const t = e.slides.length - 1,
                    s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                e.isLocked = e.size > s;
            } else e.isLocked = 1 === e.snapGrid.length;
            !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock");
        }
    },
    classes: {
        addClasses: function() {
            const e = this, {
                    classNames: t,
                    params: s,
                    rtlTranslate: a,
                    el: i,
                    device: r
                } = e,
                n = function(e, t) {
                    const s = [];
                    return e.forEach((e => {
                        "object" == typeof e ? Object.keys(e).forEach((a => {
                            e[a] && s.push(t + a);
                        })) : "string" == typeof e && s.push(t + e);
                    })), s;
                }(["initialized", s.direction, {
                    "free-mode": e.params.freeMode && s.freeMode.enabled
                }, {
                    autoheight: s.autoHeight
                }, {
                    rtl: a
                }, {
                    grid: s.grid && s.grid.rows > 1
                }, {
                    "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill
                }, {
                    android: r.android
                }, {
                    ios: r.ios
                }, {
                    "css-mode": s.cssMode
                }, {
                    centered: s.cssMode && s.centeredSlides
                }, {
                    "watch-progress": s.watchSlidesProgress
                }], s.containerModifierClass);
            t.push(...n), i.classList.add(...t), e.emitContainerClasses();
        },
        removeClasses: function() {
            const {
                el: e,
                classNames: t
            } = this;
            e && "string" != typeof e && (e.classList.remove(...t), this.emitContainerClasses());
        }
    }
};

const ie = {};

class re {
    constructor() {
        let e, t;
        for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++) i[r] = arguments[r];
        1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = p({}, t), e && !t.el && (t.el = e);
        const n = a();
        if (t.el && "string" == typeof t.el && n.querySelectorAll(t.el).length > 1) {
            const e = [];
            return n.querySelectorAll(t.el).forEach((s => {
                const a = p({}, t, {
                    el: s
                });
                e.push(new re(a));
            })), e;
        }
        const l = this;
        l.__swiper__ = !0, l.support = z(), l.device = A({
            userAgent: t.userAgent
        }), l.browser = $(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
        const o = {};
        l.modules.forEach((e => {
            e({
                params: t,
                swiper: l,
                extendParams: se(t, o),
                on: l.on.bind(l),
                once: l.once.bind(l),
                off: l.off.bind(l),
                emit: l.emit.bind(l)
            });
        }));
        const d = p({}, te, o);
        return l.params = p({}, d, ie, t), l.originalParams = p({}, l.params), l.passedParams = p({}, t), l.params && l.params.on && Object.keys(l.params.on).forEach((e => {
            l.on(e, l.params.on[e]);
        })), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, {
            enabled: l.params.enabled,
            el: e,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal: () => "horizontal" === l.params.direction,
            isVertical: () => "vertical" === l.params.direction,
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
            },
            allowSlideNext: l.params.allowSlideNext,
            allowSlidePrev: l.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: l.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: l.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }), l.emit("_swiper"), l.params.init && l.init(), l;
    }

    getDirectionLabel(e) {
        return this.isHorizontal() ? e : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[e];
    }

    getSlideIndex(e) {
        const {
            slidesEl: t,
            params: s
        } = this, a = y(f(t, `.${s.slideClass}, swiper-slide`)[0]);
        return y(e) - a;
    }

    getSlideIndexByData(e) {
        return this.getSlideIndex(this.slides.find((t => 1 * t.getAttribute("data-swiper-slide-index") === e)));
    }

    getSlideIndexWhenGrid(e) {
        return this.grid && this.params.grid && this.params.grid.rows > 1 && ("column" === this.params.grid.fill ? e = Math.floor(e / this.params.grid.rows) : "row" === this.params.grid.fill && (e %= Math.ceil(this.slides.length / this.params.grid.rows))), e;
    }

    recalcSlides() {
        const {
            slidesEl: e,
            params: t
        } = this;
        this.slides = f(e, `.${t.slideClass}, swiper-slide`);
    }

    enable() {
        const e = this;
        e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"));
    }

    disable() {
        const e = this;
        e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"));
    }

    setProgress(e, t) {
        const s = this;
        e = Math.min(Math.max(e, 0), 1);
        const a = s.minTranslate(),
            i = (s.maxTranslate() - a) * e + a;
        s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses();
    }

    emitContainerClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
        e.emit("_containerClasses", t.join(" "));
    }

    getSlideClasses(e) {
        const t = this;
        return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ");
    }

    emitSlidesClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const t = [];
        e.slides.forEach((s => {
            const a = e.getSlideClasses(s);
            t.push({
                slideEl: s,
                classNames: a
            }), e.emit("_slideClass", s, a);
        })), e.emit("_slideClasses", t);
    }

    slidesPerViewDynamic(e, t) {
        void 0 === e && (e = "current"), void 0 === t && (t = !1);
        const {
            params: s,
            slides: a,
            slidesGrid: i,
            slidesSizesGrid: r,
            size: n,
            activeIndex: l
        } = this;
        let o = 1;
        if ("number" == typeof s.slidesPerView) return s.slidesPerView;
        if (s.centeredSlides) {
            let e, t = a[l] ? Math.ceil(a[l].swiperSlideSize) : 0;
            for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += Math.ceil(a[s].swiperSlideSize), o += 1, t > n && (e = !0));
            for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));
        } else if ("current" === e)
            for (let e = l + 1; e < a.length; e += 1) {
                (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1);
            } else
                for (let e = l - 1; e >= 0; e -= 1) {
                    i[l] - i[e] < n && (o += 1);
                }
        return o;
    }

    update() {
        const e = this;
        if (!e || e.destroyed) return;
        const {
            snapGrid: t,
            params: s
        } = e;

        function a() {
            const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
            e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses();
        }
        let i;
        if (s.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => {
                t.complete && G(e, t);
            })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) a(), s.autoHeight && e.updateAutoHeight();
        else {
            if (("auto" === s.slidesPerView || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) {
                const t = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides;
                i = e.slideTo(t.length - 1, 0, !1, !0);
            } else i = e.slideTo(e.activeIndex, 0, !1, !0);
            i || a();
        }
        s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
    }

    changeDirection(e, t) {
        void 0 === t && (t = !0);
        const s = this,
            a = s.params.direction;
        return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${a}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach((t => {
            "vertical" === e ? t.style.width = "" : t.style.height = "";
        })), s.emit("changeDirection"), t && s.update()), s;
    }

    changeLanguageDirection(e) {
        const t = this;
        t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update());
    }

    mount(e) {
        const t = this;
        if (t.mounted) return !0;
        let s = e || t.params.el;
        if ("string" == typeof s && (s = document.querySelector(s)), !s) return !1;
        s.swiper = t, s.parentNode && s.parentNode.host && s.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
        const a = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
        let i = (() => {
            if (s && s.shadowRoot && s.shadowRoot.querySelector) {
                return s.shadowRoot.querySelector(a());
            }
            return f(s, a())[0];
        })();
        return !i && t.params.createElements && (i = v("div", t.params.wrapperClass), s.append(i), f(s, `.${t.params.slideClass}`).forEach((e => {
            i.append(e);
        }))), Object.assign(t, {
            el: s,
            wrapperEl: i,
            slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : i,
            hostEl: t.isElement ? s.parentNode.host : s,
            mounted: !0,
            rtl: "rtl" === s.dir.toLowerCase() || "rtl" === b(s, "direction"),
            rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === b(s, "direction")),
            wrongRTL: "-webkit-box" === b(i, "display")
        }), !0;
    }

    init(e) {
        const t = this;
        if (t.initialized) return t;
        if (!1 === t.mount(e)) return t;
        t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(void 0, !0), t.attachEvents();
        const s = [...t.el.querySelectorAll('[loading="lazy"]')];
        return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach((e => {
            e.complete ? G(t, e) : e.addEventListener("load", (e => {
                G(t, e.target);
            }));
        })), Y(t), t.initialized = !0, Y(t), t.emit("init"), t.emit("afterInit"), t;
    }

    destroy(e, t) {
        void 0 === e && (e = !0), void 0 === t && (t = !0);
        const s = this, {
            params: a,
            el: i,
            wrapperEl: r,
            slides: n
        } = s;
        return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i && "string" != typeof i && i.removeAttribute("style"), r && r.removeAttribute("style"), n && n.length && n.forEach((e => {
            e.classList.remove(a.slideVisibleClass, a.slideFullyVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index");
        }))), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => {
            s.off(e);
        })), !1 !== e && (s.el && "string" != typeof s.el && (s.el.swiper = null), function(e) {
            const t = e;
            Object.keys(t).forEach((e => {
                try {
                    t[e] = null;
                } catch (e) {}
                try {
                    delete t[e];
                } catch (e) {}
            }));
        }(s)), s.destroyed = !0), null;
    }

    static extendDefaults(e) {
        p(ie, e);
    }

    static get extendedDefaults() {
        return ie;
    }

    static get defaults() {
        return te;
    }

    static installModule(e) {
        re.prototype.__modules__ || (re.prototype.__modules__ = []);
        const t = re.prototype.__modules__;
        "function" == typeof e && t.indexOf(e) < 0 && t.push(e);
    }

    static use(e) {
        return Array.isArray(e) ? (e.forEach((e => re.installModule(e))), re) : (re.installModule(e), re);
    }
}

function ne(e, t, s, a) {
    return e.params.createElements && Object.keys(a).forEach((i => {
        if (!s[i] && !0 === s.auto) {
            let r = f(e.el, `.${a[i]}`)[0];
            r || (r = v("div", a[i]), r.className = a[i], e.el.append(r)), s[i] = r, t[i] = r;
        }
    })), s;
}

function le(e) {
    return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/()[\]])/g,"\\$1").replace(/ /g,".")}`;
}

function oe(e) {
    const t = this, {
            params: s,
            slidesEl: a
        } = t;
    s.loop && t.loopDestroy();
    const i = e => {
        if ("string" == typeof e) {
            const t = document.createElement("div");
            C(t, e), a.append(t.children[0]), C(t, "");
        } else a.append(e);
    };
    if ("object" == typeof e && "length" in e)
        for (let t = 0; t < e.length; t += 1) e[t] && i(e[t]);
    else i(e);
    t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update();
}

function de(e) {
    const t = this, {
            params: s,
            activeIndex: a,
            slidesEl: i
        } = t;
    s.loop && t.loopDestroy();
    let r = a + 1;
    const n = e => {
        if ("string" == typeof e) {
            const t = document.createElement("div");
            C(t, e), i.prepend(t.children[0]), C(t, "");
        } else i.prepend(e);
    };
    if ("object" == typeof e && "length" in e) {
        for (let t = 0; t < e.length; t += 1) e[t] && n(e[t]);
        r = a + e.length;
    } else n(e);
    t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), t.slideTo(r, 0, !1);
}

function ce(e, t) {
    const s = this, {
            params: a,
            activeIndex: i,
            slidesEl: r
        } = s;
    let n = i;
    a.loop && (n -= s.loopedSlides, s.loopDestroy(), s.recalcSlides());
    const l = s.slides.length;
    if (e <= 0) return void s.prependSlide(t);
    if (e >= l) return void s.appendSlide(t);
    let o = n > e ? n + 1 : n;
    const d = [];
    for (let t = l - 1; t >= e; t -= 1) {
        const e = s.slides[t];
        e.remove(), d.unshift(e);
    }
    if ("object" == typeof t && "length" in t) {
        for (let e = 0; e < t.length; e += 1) t[e] && r.append(t[e]);
        o = n > e ? n + t.length : n;
    } else r.append(t);
    for (let e = 0; e < d.length; e += 1) r.append(d[e]);
    s.recalcSlides(), a.loop && s.loopCreate(), a.observer && !s.isElement || s.update(), a.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1);
}

function pe(e) {
    const t = this, {
            params: s,
            activeIndex: a
        } = t;
    let i = a;
    s.loop && (i -= t.loopedSlides, t.loopDestroy());
    let r, n = i;
    if ("object" == typeof e && "length" in e) {
        for (let s = 0; s < e.length; s += 1) r = e[s], t.slides[r] && t.slides[r].remove(), r < n && (n -= 1);
        n = Math.max(n, 0);
    } else r = e, t.slides[r] && t.slides[r].remove(), r < n && (n -= 1), n = Math.max(n, 0);
    t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), s.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1);
}

function ue() {
    const e = this,
        t = [];
    for (let s = 0; s < e.slides.length; s += 1) t.push(s);
    e.removeSlide(t);
}

function me(e) {
    const {
        effect: t,
        swiper: s,
        on: a,
        setTranslate: i,
        setTransition: r,
        overwriteParams: n,
        perspective: l,
        recreateShadows: o,
        getEffectParams: d
    } = e;
    let c;
    a("beforeInit", (() => {
        if (s.params.effect !== t) return;
        s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
        const e = n ? n() : {};
        Object.assign(s.params, e), Object.assign(s.originalParams, e);
    })), a("setTranslate _virtualUpdated", (() => {
        s.params.effect === t && i();
    })), a("setTransition", ((e, a) => {
        s.params.effect === t && r(a);
    })), a("transitionEnd", (() => {
        if (s.params.effect === t && o) {
            if (!d || !d().slideShadows) return;
            s.slides.forEach((e => {
                e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((e => e.remove()));
            })), o();
        }
    })), a("virtualUpdate", (() => {
        s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => {
            c && s.slides && s.slides.length && (i(), c = !1);
        })));
    }));
}

function he(e, t) {
    const s = h(t);
    return s !== t && (s.style.backfaceVisibility = "hidden", s.style["-webkit-backface-visibility"] = "hidden"), s;
}

function fe(e) {
    let {
        swiper: t,
        duration: s,
        transformElements: a,
        allSlides: i
    } = e;
    const {
        activeIndex: r
    } = t;
    if (t.params.virtualTranslate && 0 !== s) {
        let e, s = !1;
        e = i ? a : a.filter((e => {
            const s = e.classList.contains("swiper-slide-transform") ? (e => {
                if (!e.parentElement) return t.slides.find((t => t.shadowRoot && t.shadowRoot === e.parentNode));
                return e.parentElement;
            })(e) : e;
            return t.getSlideIndex(s) === r;
        })), e.forEach((e => {
            x(e, (() => {
                if (s) return;
                if (!t || t.destroyed) return;
                s = !0, t.animating = !1;
                const e = new window.CustomEvent("transitionend", {
                    bubbles: !0,
                    cancelable: !0
                });
                t.wrapperEl.dispatchEvent(e);
            }));
        }));
    }
}

function ge(e, t, s) {
    const a = `swiper-slide-shadow${s?`-${s}`:""}${e?` swiper-slide-shadow-${e}`:""}`,
        i = h(t);
    let r = i.querySelector(`.${a.split(" ").join(".")}`);
    return r || (r = v("div", a.split(" ")), i.append(r)), r;
}

Object.keys(ae).forEach((e => {
    Object.keys(ae[e]).forEach((t => {
        re.prototype[t] = ae[e][t];
    }));
})), re.use([function(e) {
    let {
        swiper: t,
        on: s,
        emit: a
    } = e;
    const i = r();
    let n = null,
        l = null;
    const o = () => {
        t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize"));
    }, d = () => {
        t && !t.destroyed && t.initialized && a("orientationchange");
    };
    s("init", (() => {
        t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => {
            l = i.requestAnimationFrame((() => {
                const {
                    width: s,
                    height: a
                } = t;
                let i = s,
                    r = a;
                e.forEach((e => {
                    let {
                        contentBoxSize: s,
                        contentRect: a,
                        target: n
                    } = e;
                    n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize);
                })), i === s && r === a || o();
            }));
        })), n.observe(t.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", d));
    })), s("destroy", (() => {
        l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", d);
    }));
}, function(e) {
    let {
        swiper: t,
        extendParams: s,
        on: a,
        emit: i
    } = e;
    const n = [],
        l = r(),
        o = function(e, s) {
            void 0 === s && (s = {});
            const a = new(l.MutationObserver || l.WebkitMutationObserver)((e => {
                if (t.__preventObserver__) return;
                if (1 === e.length) return void i("observerUpdate", e[0]);
                const s = function() {
                    i("observerUpdate", e[0]);
                };
                l.requestAnimationFrame ? l.requestAnimationFrame(s) : l.setTimeout(s, 0);
            }));
            a.observe(e, {
                attributes: void 0 === s.attributes || s.attributes,
                childList: t.isElement || (void 0 === s.childList || s).childList,
                characterData: void 0 === s.characterData || s.characterData
            }), n.push(a);
        };
    s({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }), a("init", (() => {
        if (t.params.observer) {
            if (t.params.observeParents) {
                const e = E(t.hostEl);
                for (let t = 0; t < e.length; t += 1) o(e[t]);
            }
            o(t.hostEl, {
                childList: t.params.observeSlideChildren
            }), o(t.wrapperEl, {
                attributes: !1
            });
        }
    })), a("destroy", (() => {
        n.forEach((e => {
            e.disconnect();
        })), n.splice(0, n.length);
    }));
}]);

const ve = [function(e) {
    let t, {
            swiper: s,
            extendParams: i,
            on: r,
            emit: n
        } = e;
    i({
        virtual: {
            enabled: !1,
            slides: [],
            cache: !0,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: !0,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    });
    const l = a();
    s.virtual = {
        cache: {},
        from: void 0,
        to: void 0,
        slides: [],
        offset: 0,
        slidesGrid: []
    };
    const o = l.createElement("div");

    function d(e, t) {
        const a = s.params.virtual;
        if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];
        let i;
        return a.renderSlide ? (i = a.renderSlide.call(s, e, t), "string" == typeof i && (C(o, i), i = o.children[0])) : i = s.isElement ? v("swiper-slide") : v("div", s.params.slideClass), i.setAttribute("data-swiper-slide-index", t), a.renderSlide || C(i, e), a.cache && (s.virtual.cache[t] = i), i;
    }

    function c(e, t, a) {
        const {
            slidesPerView: i,
            slidesPerGroup: r,
            centeredSlides: l,
            loop: o,
            initialSlide: c
        } = s.params;
        if (t && !o && c > 0) return;
        const {
                addSlidesBefore: p,
                addSlidesAfter: u
            } = s.params.virtual, {
                from: m,
                to: h,
                slides: g,
                slidesGrid: v,
                offset: w
            } = s.virtual;
        s.params.cssMode || s.updateActiveIndex();
        const b = void 0 === a ? s.activeIndex || 0 : a;
        let y, E, x;
        y = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", l ? (E = Math.floor(i / 2) + r + u, x = Math.floor(i / 2) + r + p) : (E = i + (r - 1) + u, x = (o ? i : r) + p);
        let S = b - x,
            T = b + E;
        o || (S = Math.max(S, 0), T = Math.min(T, g.length - 1));
        let M = (s.slidesGrid[S] || 0) - (s.slidesGrid[0] || 0);

        function C() {
            s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), n("virtualUpdate");
        }
        if (o && b >= x ? (S -= x, l || (M += s.slidesGrid[0])) : o && b < x && (S = -x, l && (M += s.slidesGrid[0])), Object.assign(s.virtual, {
                from: S,
                to: T,
                offset: M,
                slidesGrid: s.slidesGrid,
                slidesBefore: x,
                slidesAfter: E
            }), m === S && h === T && !e) return s.slidesGrid !== v && M !== w && s.slides.forEach((e => {
            e.style[y] = M - Math.abs(s.cssOverflowAdjustment()) + "px";
        })), s.updateProgress(), void n("virtualUpdate");
        if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
            offset: M,
            from: S,
            to: T,
            slides: function() {
                const e = [];
                for (let t = S; t <= T; t += 1) e.push(g[t]);
                return e;
            }()
        }), void(s.params.virtual.renderExternalUpdate ? C() : n("virtualUpdate"));
        const P = [],
            L = [],
            I = e => {
                let t = e;
                return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t;
            };
        if (e) s.slides.filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`))).forEach((e => {
            e.remove();
        }));
        else
            for (let e = m; e <= h; e += 1)
                if (e < S || e > T) {
                    const t = I(e);
                    s.slides.filter((e => e.matches(`.${s.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`))).forEach((e => {
                        e.remove();
                    }));
                }
        const z = o ? -g.length : 0,
            A = o ? 2 * g.length : g.length;
        for (let t = z; t < A; t += 1)
            if (t >= S && t <= T) {
                const s = I(t);
                void 0 === h || e ? L.push(s) : (t > h && L.push(s), t < m && P.push(s));
            }
        if (L.forEach((e => {
                s.slidesEl.append(d(g[e], e));
            })), o)
            for (let e = P.length - 1; e >= 0; e -= 1) {
                const t = P[e];
                s.slidesEl.prepend(d(g[t], t));
            } else P.sort(((e, t) => t - e)), P.forEach((e => {
            s.slidesEl.prepend(d(g[e], e));
        }));
        f(s.slidesEl, ".swiper-slide, swiper-slide").forEach((e => {
            e.style[y] = M - Math.abs(s.cssOverflowAdjustment()) + "px";
        })), C();
    }
    r("beforeInit", (() => {
        if (!s.params.virtual.enabled) return;
        let e;
        if (void 0 === s.passedParams.virtual.slides) {
            const t = [...s.slidesEl.children].filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`)));
            t && t.length && (s.virtual.slides = [...t], e = !0, t.forEach(((e, t) => {
                e.setAttribute("data-swiper-slide-index", t), s.virtual.cache[t] = e, e.remove();
            })));
        } else e || (s.virtual.slides = s.params.virtual.slides), s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, c(!1, !0);
    })), r("setTranslate", (() => {
        s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => {
            c();
        }), 100)) : c());
    })), r("init update resize", (() => {
        s.params.virtual.enabled && s.params.cssMode && u(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`);
    })), Object.assign(s.virtual, {
        appendSlide: function(e) {
            if ("object" == typeof e && "length" in e)
                for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]);
            else s.virtual.slides.push(e);
            c(!0);
        },
        prependSlide: function(e) {
            const t = s.activeIndex;
            let a = t + 1,
                i = 1;
            if (Array.isArray(e)) {
                for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);
                a = t + e.length, i = e.length;
            } else s.virtual.slides.unshift(e);
            if (s.params.virtual.cache) {
                const e = s.virtual.cache,
                    t = {};
                Object.keys(e).forEach((s => {
                    const a = e[s],
                        r = a.getAttribute("data-swiper-slide-index");
                    r && a.setAttribute("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a;
                })), s.virtual.cache = t;
            }
            c(!0), s.slideTo(a, 0);
        },
        removeSlide: function(e) {
            if (null == e) return;
            let t = s.activeIndex;
            if (Array.isArray(e))
                for (let a = e.length - 1; a >= 0; a -= 1) s.params.virtual.cache && (delete s.virtual.cache[e[a]], Object.keys(s.virtual.cache).forEach((t => {
                    t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete s.virtual.cache[t]);
                })), s.virtual.slides.splice(e[a], 1), e[a] < t && (t -= 1), t = Math.max(t, 0);
            else s.params.virtual.cache && (delete s.virtual.cache[e], Object.keys(s.virtual.cache).forEach((t => {
                t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete s.virtual.cache[t]);
            })), s.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0);
            c(!0), s.slideTo(t, 0);
        },
        removeAllSlides: function() {
            s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), c(!0), s.slideTo(0, 0);
        },
        update: c
    });
}, function(e) {
    let t, {
            swiper: s,
            extendParams: i,
            on: r,
            emit: n
        } = e;
    const l = a(),
        o = r();
    i({
        keyboard: {
            enabled: !1,
            onlyInViewport: !0,
            pageUpDown: !0
        }
    }), s.keyboard = {
        enabled: !1
    };

    function d(e) {
        if (!s.enabled) return;
        const {
            rtlTranslate: t
        } = s;
        let a = e;
        a.originalEvent && (a = a.originalEvent);
        const i = a.keyCode || a.charCode,
            r = s.params.keyboard.pageUpDown,
            d = r && 33 === i,
            c = r && 34 === i,
            p = 37 === i,
            u = 39 === i,
            m = 38 === i,
            h = 40 === i;
        if (!s.allowSlideNext && (s.isHorizontal() && u || s.isVertical() && h || c)) return !1;
        if (!s.allowSlidePrev && (s.isHorizontal() && p || s.isVertical() && m || d)) return !1;
        if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && (l.activeElement.isContentEditable || l.activeElement.nodeName && ("input" === l.activeElement.nodeName.toLowerCase() || "textarea" === l.activeElement.nodeName.toLowerCase())))) {
            if (s.params.keyboard.onlyInViewport && (d || c || p || u || m || h)) {
                let e = !1;
                if (E(s.el, `.${s.params.slideClass}, swiper-slide`).length > 0 && 0 === E(s.el, `.${s.params.slideActiveClass}`).length) return;
                const a = s.el,
                    i = a.clientWidth,
                    r = a.clientHeight,
                    n = o.innerWidth,
                    l = o.innerHeight,
                    d = w(a);
                t && (d.left -= a.scrollLeft);
                const c = [
                    [d.left, d.top],
                    [d.left + i, d.top],
                    [d.left, d.top + r],
                    [d.left + i, d.top + r]
                ];
                for (let t = 0; t < c.length; t += 1) {
                    const s = c[t];
                    if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {
                        if (0 === s[0] && 0 === s[1]) continue;
                        e = !0;
                    }
                }
                if (!e) return;
            }
            s.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !t || (d || p) && t) && s.slideNext(), ((d || p) && !t || (c || u) && t) && s.slidePrev()) : ((d || c || m || h) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || h) && s.slideNext(), (d || m) && s.slidePrev()), n("keyPress", i);
        }
    }

    function c() {
        s.keyboard.enabled || (l.addEventListener("keydown", d), s.keyboard.enabled = !0);
    }

    function p() {
        s.keyboard.enabled && (l.removeEventListener("keydown", d), s.keyboard.enabled = !1);
    }
    r("init", (() => {
        s.params.keyboard.enabled && c();
    })), r("destroy", (() => {
        s.keyboard.enabled && p();
    })), Object.assign(s.keyboard, {
        enable: c,
        disable: p
    });
}, function(e) {
    let {
        swiper: t,
        extendParams: s,
        on: a,
        emit: i
    } = e;
    const n = r();
    let d;
    s({
        mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
            noMousewheelClass: "swiper-no-mousewheel"
        }
    }), t.mousewheel = {
        enabled: !1
    };
    let c, p = o();
    const u = [];

    function m() {
        t.enabled && (t.mouseEntered = !0);
    }

    function h() {
        t.enabled && (t.mouseEntered = !1);
    }

    function f(e) {
        return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && o() - p < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && o() - p < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i("scroll", e.raw))), p = (new n.Date).getTime(), !1)));
    }

    function g(e) {
        let s = e,
            a = !0;
        if (!t.enabled) return;
        if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`)) return;
        const r = t.params.mousewheel;
        t.params.cssMode && s.preventDefault();
        let n = t.el;
        "container" !== t.params.mousewheel.eventsTarget && (n = document.querySelector(t.params.mousewheel.eventsTarget));
        const p = n && n.contains(s.target);
        if (!t.mouseEntered && !p && !r.releaseOnEdges) return !0;
        s.originalEvent && (s = s.originalEvent);
        let m = 0;
        const h = t.rtlTranslate ? -1 : 1,
            g = function(e) {
                let t = 0,
                    s = 0,
                    a = 0,
                    i = 0;
                return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
                    spinX: t,
                    spinY: s,
                    pixelX: a,
                    pixelY: i
                };
            }(s);
        if (r.forceToAxis)
            if (t.isHorizontal()) {
                if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
                m = -g.pixelX * h;
            } else {
                if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
                m = -g.pixelY;
            } else m = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * h : -g.pixelY;
        if (0 === m) return !0;
        r.invert && (m = -m);
        let v = t.getTranslate() + m * r.sensitivity;
        if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
            const e = {
                time: o(),
                delta: Math.abs(m),
                direction: Math.sign(m)
            }, a = c && e.time < c.time + 500 && e.delta <= c.delta && e.direction === c.direction;
            if (!a) {
                c = void 0;
                let n = t.getTranslate() + m * r.sensitivity;
                const o = t.isBeginning,
                    p = t.isEnd;
                if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!o && t.isBeginning || !p && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({
                        direction: e.direction < 0 ? "next" : "prev",
                        byMousewheel: !0
                    }), t.params.freeMode.sticky) {
                    clearTimeout(d), d = void 0, u.length >= 15 && u.shift();
                    const s = u.length ? u[u.length - 1] : void 0,
                        a = u[0];
                    if (u.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) u.splice(0);
                    else if (u.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
                        const s = m > 0 ? .8 : .2;
                        c = e, u.splice(0), d = l((() => {
                            !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, s);
                        }), 0);
                    }
                    d || (d = l((() => {
                        if (t.destroyed || !t.params) return;
                        c = e, u.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5);
                    }), 500));
                }
                if (a || i("scroll", s), t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(), r.releaseOnEdges && (n === t.minTranslate() || n === t.maxTranslate())) return !0;
            }
        } else {
            const s = {
                time: o(),
                delta: Math.abs(m),
                direction: Math.sign(m),
                raw: e
            };
            u.length >= 2 && u.shift();
            const a = u.length ? u[u.length - 1] : void 0;
            if (u.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && f(s) : f(s), function(e) {
                    const s = t.params.mousewheel;
                    if (e.direction < 0) {
                        if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0;
                    } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;
                    return !1;
                }(s)) return !0;
        }
        return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1;
    }

    function v(e) {
        let s = t.el;
        "container" !== t.params.mousewheel.eventsTarget && (s = document.querySelector(t.params.mousewheel.eventsTarget)), s[e]("mouseenter", m), s[e]("mouseleave", h), s[e]("wheel", g);
    }

    function w() {
        return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0);
    }

    function b() {
        return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0);
    }
    a("init", (() => {
        !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && w();
    })), a("destroy", (() => {
        t.params.cssMode && w(), t.mousewheel.enabled && b();
    })), Object.assign(t.mousewheel, {
        enable: w,
        disable: b
    });
}, function(e) {
    let {
        swiper: t,
        extendParams: s,
        on: a,
        emit: i
    } = e;

    function r(e, s) {
        const a = t.isElement ? "swiper-slide" : `.${t.params.slideClass}`;
        return !!e.target.matches(a) || t.slides.filter((t => t.contains(e.target))).length > 0;
    }

    function n(e, s) {
        const a = t.params.navigation;
        (e = T(e)).forEach((e => {
            e.classList[s ? "add" : "remove"](...a.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = s), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](a.lockClass);
        }));
    }

    function l() {
        const {
            nextEl: e,
            prevEl: s
        } = t.navigation;
        if (t.params.loop) return n(s, !1), void n(e, !1);
        n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind);
    }

    function o(e) {
        e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i("navigationPrev"));
    }

    function d(e) {
        e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i("navigationNext"));
    }

    function c() {
        const e = t.params.navigation;
        if (t.params.navigation = ne(t, t.originalParams.navigation, t.params.navigation, {
                nextEl: "swiper-button-next",
                prevEl: "swiper-button-prev"
            }), !e.nextEl && !e.prevEl) return;
        let s = r(e.nextEl),
            a = r(e.prevEl);
        Object.assign(t.navigation, {
            nextEl: s,
            prevEl: a
        }), s = T(s), a = T(a);
        const i = (s, a) => {
            s && s.addEventListener("click", "next" === a ? d : o), !t.enabled && s && s.classList.add(...e.lockClass.split(" "));
        };
        s.forEach((e => i(e, "next"))), a.forEach((e => i(e, "prev")));
    }

    function p() {
        let {
            nextEl: e,
            prevEl: s
        } = t.navigation;
        e = T(e), s = T(s);
        const a = (e, s) => {
            e.removeEventListener("click", "next" === s ? d : o), e.classList.remove(...t.params.navigation.disabledClass.split(" "));
        };
        e.forEach((e => a(e, "next"))), s.forEach((e => a(e, "prev")));
    }
    s({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }), t.navigation = {
        nextEl: null,
        prevEl: null
    }, a("init", (() => {
        !1 === t.params.navigation.enabled ? u() : (c(), l());
    })), a("toEdge fromEdge lock unlock", (() => {
        l();
    })), a("destroy", (() => {
        p();
    })), a("enable disable", (() => {
        let {
            nextEl: e,
            prevEl: s
        } = t.navigation;
        e = T(e), s = T(s), t.enabled ? l() : [...e, ...s].filter((e => !!e)).forEach((e => e.classList.add(t.params.navigation.lockClass)));
    })), a("click", ((e, s) => {
        let {
            nextEl: a,
            prevEl: r
        } = t.navigation;
        a = T(a), r = T(r);
        const n = s.target;
        let l = r.includes(n) || a.includes(n);
        if (t.isElement && !l) {
            const e = s.path || s.composedPath && s.composedPath();
            e && (l = e.find((e => a.includes(e) || r.includes(e))));
        }
        if (t.params.navigation.hideOnClick && !l) {
            if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return;
            let e;
            a.length ? e = a[0].classList.contains(t.params.navigation.hiddenClass) : r.length && (e = r[0].classList.contains(t.params.navigation.hiddenClass)), i(!0 === e ? "navigationShow" : "navigationHide"), [...a, ...r].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass)));
        }
    }));
    const u = () => {
        t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), p();
    };
    Object.assign(t.navigation, {
        enable: () => {
            t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), c(), l();
        },
        disable: u,
        update: l,
        init: c,
        destroy: p
    });
}, function(e) {
    let t, {
            swiper: s,
            extendParams: a,
            on: i,
            emit: n
        } = e;
    const l = "swiper-pagination";
    let o;
    a({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: e => e,
            formatFractionTotal: e => e,
            bulletClass: `${l}-bullet`,
            bulletActiveClass: `${l}-bullet-active`,
            modifierClass: `${l}-`,
            currentClass: `${l}-current`,
            totalClass: `${l}-total`,
            hiddenClass: `${l}-hidden`,
            progressbarFillClass: `${l}-progressbar-fill`,
            progressbarOppositeClass: `${l}-progressbar-opposite`,
            clickableClass: `${l}-clickable`,
            lockClass: `${l}-lock`,
            horizontalClass: `${l}-horizontal`,
            verticalClass: `${l}-vertical`,
            paginationDisabledClass: `${l}-disabled`
        }
    }), s.pagination = {
        el: null,
        bullets: []
    };
    let d = 0;

    function c() {
        return !s.params.pagination.el || !s.pagination.el || Array.isArray(s.pagination.el) && 0 === s.pagination.el.length;
    }

    function p(e, s) {
        const {
            bulletActiveClass: a
        } = s.params.pagination;
        e && (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${a}-${s}`), (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${a}-${s}-${s}`));
    }

    function u(e) {
        const s = e.target.closest(le(s.params.pagination.bulletClass));
        if (!s) return;
        e.preventDefault();
        const a = y(s) * s.params.slidesPerGroup;
        if (s.params.loop) {
            if (s.realIndex === a) return;
            const e = (i = s.realIndex, r = a, n = s.slides.length, (r %= n) == 1 + (i %= n) ? "next" : r === i - 1 ? "previous" : void 0);
            "next" === e ? s.slideNext() : "previous" === e ? s.slidePrev() : s.slideToLoop(a);
        } else s.slideTo(a);
        var i, r, n;
    }

    function m() {
        const e = s.rtl,
            a = s.params.pagination;
        if (c()) return;
        let r, c, p = s.pagination.el;
        p = T(p);
        const u = s.virtual && s.params.virtual.enabled ? s.virtual.slides.length : s.slides.length,
            m = s.params.loop ? Math.ceil(u / s.params.slidesPerGroup) : s.snapGrid.length;
        if (s.params.loop ? (r = s.previousRealIndex || 0, c = s.params.slidesPerGroup > 1 ? Math.floor(s.realIndex / s.params.slidesPerGroup) : s.realIndex) : void 0 !== s.snapIndex ? (c = s.snapIndex, r = s.previousSnapIndex) : (r = s.previousIndex || 0, c = s.activeIndex || 0), "bullets" === a.type && s.pagination.bullets && s.pagination.bullets.length > 0) {
            const i = s.pagination.bullets;
            let o, p, u;
            if (a.dynamicBullets && (o = S(i[0], s.isHorizontal() ? "width" : "height", !0), p.forEach((e => {
                    e.style[s.isHorizontal() ? "width" : "height"] = o * (a.dynamicMainBullets + 4) + "px";
                })), a.dynamicMainBullets > 1 && void 0 !== r && (d += c - (r || 0), d > a.dynamicMainBullets - 1 ? d = a.dynamicMainBullets - 1 : d < 0 && (d = 0)), o = Math.max(c - d, 0), p = o + (Math.min(i.length, a.dynamicMainBullets) - 1), u = (p + o) / 2), i.forEach((e => {
                    const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${a.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat();
                    e.classList.remove(...t);
                })), p.length > 1) i.forEach((e => {
                const i = y(e);
                i === c ? e.classList.add(...a.bulletActiveClass.split(" ")) : s.isElement && e.setAttribute("part", "bullet"), a.dynamicBullets && (i >= o && i <= p && e.classList.add(...`${a.bulletActiveClass}-main`.split(" ")), i === o && p(e, "prev"), i === p && p(e, "next"));
            }));
            else {
                const e = i[c];
                if (e && e.classList.add(...a.bulletActiveClass.split(" ")), s.isElement && i.forEach(((e, t) => {
                        e.setAttribute("part", t === c ? "bullet-active" : "bullet");
                    })), a.dynamicBullets) {
                    const e = i[o],
                        t = i[p];
                    for (let e = o; e <= p; e += 1) i[e] && i[e].classList.add(...`${a.bulletActiveClass}-main`.split(" "));
                    p(e, "prev"), p(t, "next");
                }
            }
            if (a.dynamicBullets) {
                const a = Math.min(i.length, a.dynamicMainBullets + 4),
                    r = (o * a - o) / 2 - u * o,
                    l = e ? "right" : "left";
                i.forEach((e => {
                    e.style[s.isHorizontal() ? l : "top"] = `${r}px`;
                }));
            }
        }
        p.forEach(((e, r) => {
            if ("fraction" === a.type && (e.querySelectorAll(le(a.currentClass)).forEach((e => {
                    e.textContent = a.formatFractionCurrent(c + 1);
                })), e.querySelectorAll(le(a.totalClass)).forEach((e => {
                    e.textContent = a.formatFractionTotal(m);
                }))), "progressbar" === a.type) {
                let i;
                i = a.progressbarOpposite ? s.isHorizontal() ? "vertical" : "horizontal" : s.isHorizontal() ? "horizontal" : "vertical";
                const r = (c + 1) / m;
                let n = 1,
                    l = 1;
                "horizontal" === i ? n = r : l = r, e.querySelectorAll(le(a.progressbarFillClass)).forEach((e => {
                    e.style.transform = `translate3d(0,0,0) scaleX(${n}) scaleY(${l})`, e.style.transitionDuration = `${s.params.speed}ms`;
                }));
            }
            "custom" === a.type && a.renderCustom ? (C(e, a.renderCustom(s, c + 1, m)), 0 === r && n("paginationRender", e)) : (0 === r && n("paginationRender", e), n("paginationUpdate", e)), s.params.watchOverflow && s.enabled && e.classList[s.isLocked ? "add" : "remove"](a.lockClass);
        }));
    }

    function h() {
        const e = s.params.pagination;
        if (c()) return;
        const a = s.virtual && s.params.virtual.enabled ? s.virtual.slides.length : s.grid && s.params.grid.rows > 1 ? s.slides.length / Math.ceil(s.params.grid.rows) : s.slides.length;
        let i = s.pagination.el;
        i = T(i);
        let r = "";
        if ("bullets" === e.type) {
            let a = s.params.loop ? Math.ceil(a / s.params.slidesPerGroup) : s.snapGrid.length;
            s.params.freeMode && s.params.freeMode.enabled && a > a && (a = a);
            for (let s = 0; s < a; s += 1) e.renderBullet ? r += e.renderBullet.call(s, s, e.bulletClass) : r += `<${e.bulletElement} ${s.isElement?'part="bullet"':""} class="${e.bulletClass}"></${e.bulletElement}>`;
        }
        "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(s, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(s, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), s.pagination.bullets = [], i.forEach((s => {
            "custom" !== e.type && C(s, r || ""), "bullets" === e.type && s.pagination.bullets.push(...s.querySelectorAll(le(e.bulletClass)));
        })), "custom" !== e.type && n("paginationRender", i[0]);
    }

    function f() {
        s.params.pagination = ne(s, s.originalParams.pagination, s.params.pagination, {
            el: "swiper-pagination"
        });
        const e = s.params.pagination;
        if (!e.el) return;
        let a;
        "string" == typeof e.el && s.isElement && (a = s.el.querySelector(e.el)), a || "string" != typeof e.el || (a = [...document.querySelectorAll(e.el)]), a || (a = e.el), a && 0 !== a.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(a) && a.length > 1 && (a = [...s.el.querySelectorAll(e.el)], a.length > 1 && (a = a.find((e => E(e, ".swiper")[0] === s.el)))), Array.isArray(a) && 1 === a.length && (a = a[0]), Object.assign(s.pagination, {
            el: a
        }), a = T(a), a.forEach((s => {
            "bullets" === e.type && e.clickable && s.classList.add(...(e.clickableClass || "").split(" ")), s.classList.add(e.modifierClass + e.type), s.classList.add(s.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`), d = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass), e.clickable && s.addEventListener("click", u), s.enabled || s.classList.add(e.lockClass);
        })));
    }

    function g() {
        const e = s.params.pagination;
        if (c()) return;
        let a = s.pagination.el;
        a && (a = T(a), a.forEach((s => {
            s.classList.remove(e.hiddenClass), s.classList.remove(e.modifierClass + e.type), s.classList.remove(s.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (s.classList.remove(...(e.clickableClass || "").split(" ")), s.removeEventListener("click", u));
        })), s.pagination.bullets && s.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" "))));
    }
    i("changeDirection", (() => {
        if (!s.pagination || !s.pagination.el) return;
        const e = s.params.pagination;
        let {
            el: a
        } = s.pagination;
        a = T(a), a.forEach((s => {
            s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(s.isHorizontal() ? e.horizontalClass : e.verticalClass);
        }));
    })), i("init", (() => {
        !1 === s.params.pagination.enabled ? v() : (f(), h(), m());
    })), i("activeIndexChange", (() => {
        void 0 === s.snapIndex && m();
    })), i("snapIndexChange", (() => {
        m();
    })), i("snapGridLengthChange", (() => {
        h(), m();
    })), i("destroy", (() => {
        g();
    })), i("enable disable", (() => {
        let {
            el: e
        } = s.pagination;
        e && (e = T(e), e.forEach((e => e.classList[s.enabled ? "remove" : "add"](s.params.pagination.lockClass))));
    })), i("lock unlock", (() => {
        m();
    })), i("click", ((e, s) => {
        const a = s.target,
            r = T(s.pagination.el);
        if (s.params.pagination.el && s.params.pagination.hideOnClick && r && r.length > 0 && !a.classList.contains(s.params.pagination.bulletClass)) {
            if (s.navigation && (s.navigation.nextEl && a === s.navigation.nextEl || s.navigation.prevEl && a === s.navigation.prevEl)) return;
            const e = r[0].classList.contains(s.params.pagination.hiddenClass);
            n(!0 === e ? "paginationShow" : "paginationHide"), r.forEach((e => e.classList.toggle(s.params.pagination.hiddenClass)));
        }
    }));
    const v = () => {
        s.el.classList.add(s.params.pagination.paginationDisabledClass);
        let {
            el: e
        } = s.pagination;
        e && (e = T(e), e.forEach((e => e.classList.add(s.params.pagination.paginationDisabledClass)))), g();
    };
    Object.assign(s.pagination, {
        enable: () => {
            s.el.classList.remove(s.params.pagination.paginationDisabledClass);
            let {
                el: e
            } = s.pagination;
            e && (e = T(e), e.forEach((e => e.classList.remove(s.params.pagination.paginationDisabledClass)))), f(), h(), m();
        },
        disable: v,
        render: h,
        update: m,
        init: f,
        destroy: g
    });
}, function(e) {
    let {
        swiper: t,
        extendParams: s,
        on: a,
        emit: i
    } = e;
    const n = a();
    let d, c, p, u, m = !1,
        h = null,
        f = null;

    function g() {
        if (!t.params.scrollbar.el || !t.scrollbar.el) return;
        const {
            scrollbar: e,
            rtlTranslate: s
        } = t, {
            dragEl: a,
            el: i
        } = e, r = t.params.scrollbar, n = t.params.loop ? t.progressLoop : t.progress;
        let l = c,
            o = (p - c) * n;
        s && (o = -o, o > 0 ? (l = c - o, o = 0) : -o + c > p && (l = p + o)), t.isHorizontal() ? (a.style.transform = `translate3d(${o}px, 0, 0)`, a.style.width = `${l}px`) : (a.style.transform = `translate3d(0px, ${o}px, 0)`, a.style.height = `${l}px`), r.hide && (clearTimeout(h), i.style.opacity = 1, h = setTimeout((() => {
            i.style.opacity = 0, i.style.transitionDuration = "400ms";
        }), 1e3));
    }

    function v() {
        if (!t.params.scrollbar.el || !t.scrollbar.el) return;
        const {
            scrollbar: e
        } = t, {
            dragEl: s,
            el: a
        } = e;
        s.style.width = "", s.style.height = "", p = t.isHorizontal() ? a.offsetWidth : a.offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), c = "auto" === t.params.scrollbar.dragSize ? p * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s.style.width = `${c}px` : s.style.height = `${c}px`, a.style.display = u >= 1 ? "none" : "", t.params.scrollbar.hide && (a.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass);
    }

    function w(e) {
        return t.isHorizontal() ? e.clientX : e.clientY;
    }

    function b(e) {
        const {
            scrollbar: s,
            rtlTranslate: a
        } = t, {
            el: i
        } = s;
        let r;
        r = (w(e) - w(i)[t.isHorizontal() ? "left" : "top"] - (null !== d ? d : c / 2)) / (p - c), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
        const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
        t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses();
    }

    function y(e) {
        const s = t.params.scrollbar, {
            scrollbar: a,
            wrapperEl: i
        } = t, {
            el: r,
            dragEl: n
        } = a;
        m = !0, d = e.target === n ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.style.transitionDuration = "100ms", n.style.transitionDuration = "100ms", b(e), clearTimeout(f), r.style.transitionDuration = "0ms", s.hide && (r.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), i("scrollbarDragStart", e);
    }

    function E(e) {
        const {
            scrollbar: s,
            wrapperEl: a
        } = t, {
            el: i,
            dragEl: r
        } = s;
        m && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, b(e), a.style.transitionDuration = "0ms", i.style.transitionDuration = "0ms", r.style.transitionDuration = "0ms", i("scrollbarDragMove", e));
    }

    function x(e) {
        const s = t.params.scrollbar, {
            scrollbar: a,
            wrapperEl: i
        } = t, {
            el: r
        } = a;
        m && (m = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", i.style.transitionDuration = ""), s.hide && (clearTimeout(f), f = l((() => {
            r.style.opacity = 0, r.style.transitionDuration = "400ms";
        }), 1e3)), i("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest());
    }

    function S(e) {
        const {
            scrollbar: s,
            params: a
        } = t, i = s.el;
        if (!i) return;
        const r = i, n = !!a.passiveListeners && {
            passive: !1,
            capture: !1
        }, l = !!a.passiveListeners && {
            passive: !0,
            capture: !1
        };
        if (!r) return;
        const d = "on" === e ? "addEventListener" : "removeEventListener";
        r[d]("pointerdown", y, n), n[d]("pointermove", E, n), n[d]("pointerup", x, l);
    }

    function T() {
        const {
            scrollbar: e,
            el: s
        } = t;
        t.params.scrollbar = ne(t, t.originalParams.scrollbar, t.params.scrollbar, {
            el: "swiper-scrollbar"
        });
        const a = t.params.scrollbar;
        if (!a.el) return;
        let i, r;
        if ("string" == typeof a.el && t.isElement && (i = t.el.querySelector(a.el)), i || "string" != typeof a.el || (i = n.querySelectorAll(a.el)), !i.length) return;
        t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.querySelectorAll(a.el).length && (i = s.querySelector(a.el)), Array.isArray(i) && 1 === i.length && (i = i[0]), i.classList.add(t.isHorizontal() ? a.horizontalClass : a.verticalClass), i && (r = i.querySelector(le(t.params.scrollbar.dragClass)), r || (r = v("div", t.params.scrollbar.dragClass), i.append(r))), Object.assign(t.scrollbar, {
            el: i,
            dragEl: r
        }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && S("on"), i && i.classList[t.enabled ? "remove" : "add"](...n(t.params.scrollbar.lockClass));
    }

    function M() {
        const e = t.params.scrollbar,
            s = t.scrollbar.el;
        s && s.classList.remove(...n(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && S("off");
    }
    s({
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: "swiper-scrollbar-horizontal",
            verticalClass: "swiper-scrollbar-vertical"
        }
    }), t.scrollbar = {
        el: null,
        dragEl: null
    }, a("changeDirection", (() => {
        if (!t.scrollbar || !t.scrollbar.el) return;
        const e = t.params.scrollbar;
        let {
            el: s
        } = t.scrollbar;
        s = T(s), s.forEach((s => {
            s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass);
        }));
    })), a("init", (() => {
        !1 === t.params.scrollbar.enabled ? I() : (T(), v(), g());
    })), a("update resize observerUpdate lock unlock changeDirection", (() => {
        v();
    })), a("setTranslate", (() => {
        g();
    })), a("setTransition", ((e, s) => {
        !function(e) {
            t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = `${e}ms`);
        }(s);
    })), a("enable disable", (() => {
        const {
            el: e
        } = t.scrollbar;
        e && e.classList[t.enabled ? "remove" : "add"](...n(t.params.scrollbar.lockClass));
    })), a("destroy", (() => {
        M();
    }));
    const C = () => {
        t.el.classList.add(...n(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...n(t.params.scrollbar.scrollbarDisabledClass)), M();
    };
    Object.assign(t.scrollbar, {
        enable: () => {
            t.el.classList.remove(...n(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...n(t.params.scrollbar.scrollbarDisabledClass)), T(), v(), g();
        },
        disable: C,
        updateSize: v,
        setTranslate: g,
        init: T,
        destroy: M
    });
}, function(e) {
    let {
        swiper: t,
        extendParams: s,
        on: a
    } = e;
    s({
        parallax: {
            enabled: !1
        }
    });
    const i = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", r = (e, s) => {
        const {
            rtlTranslate: a
        } = t, i = a ? -1 : 1, r = e.getAttribute("data-swiper-parallax") || "0";
        let n = e.getAttribute("data-swiper-parallax-x"),
            l = e.getAttribute("data-swiper-parallax-y");
        const o = e.getAttribute("data-swiper-parallax-scale"),
            d = e.getAttribute("data-swiper-parallax-opacity"),
            c = e.getAttribute("data-swiper-parallax-rotate");
        if (n || l ? (n = n || "0", l = l || "0") : t.isHorizontal() ? (n = r, l = "0") : (l = r, n = "0"), n = n.indexOf("%") >= 0 ? parseInt(n, 10) * s * i + "%" : n * s * i + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s + "%" : l * s + "px", null != d) {
            const t = d - (d - 1) * (1 - Math.abs(s));
            e.style.opacity = t;
        }
        let p = `translate3d(${n}, ${l}, 0px)`;
        if (null != o) {
            p += ` scale(${o-(o-1)*(1-Math.abs(s))})`;
        }
        if (c && null != c) {
            p += ` rotate(${c*s*-1}deg)`;
        }
        e.style.transform = p;
    }, n = () => {
        const {
            el: e,
            slides: s,
            progress: a,
            snapGrid: i,
            isElement: n
        } = t, l = f(e, i);
        t.isElement && l.push(...f(t.hostEl, i)), l.forEach((e => {
            r(e, a);
        })), s.forEach(((e, s) => {
            let l = e.progress;
            t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (l += Math.ceil(s / 2) - a * (i.length - 1)), l = Math.min(Math.max(l, -1), 1), e.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach((e => {
                r(e, l);
            }));
        }));
    };
    a("beforeInit", (() => {
        t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0);
    })), a("init", (() => {
        t.params.parallax.enabled && n();
    })), a("setTranslate", (() => {
        t.params.parallax.enabled && n();
    })), a("setTransition", ((e, s) => {
        t.params.parallax.enabled && function(e) {
            void 0 === e && (e = t.params.speed);
            const {
                el: s,
                hostEl: a
            } = t, r = [...s.querySelectorAll(i)];
            t.isElement && r.push(...a.querySelectorAll(i)), r.forEach((t => {
                let s = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
                0 === e && (s = 0), t.style.transitionDuration = `${s}ms`;
            }));
        }(s);
    }));
}, function(e) {
    let t, s, a, i, {
            swiper: r,
            extendParams: n,
            on: l,
            emit: o
        } = e;
    n({
        zoom: {
            enabled: !1,
            limitToOriginalSize: !1,
            maxRatio: 3,
            minRatio: 1,
            panOnMouseMove: !1,
            toggle: !0,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    }), r.zoom = {
        enabled: !1
    };
    let d = 1,
        c = !1,
        p = !1,
        u = {
            x: 0,
            y: 0
        };
    const m = -3;
    let h, f;
    const g = [],
        v = {
            originX: 0,
            originY: 0,
            slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            imageEl: void 0,
            imageWrapEl: void 0,
            maxRatio: 3
        }, w = {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {}
        }, b = {
            x: void 0,
            y: void 0,
            prevPositionX: void 0,
            prevPositionY: void 0,
            prevTime: void 0
        };
    let y, E = 1;

    function x() {
        if (g.length < 2) return 1;
        const e = g[0].pageX,
            t = g[0].pageY,
            s = g[1].pageX,
            a = g[1].pageY;
        return Math.sqrt((s - e) ** 2 + (a - t) ** 2);
    }

    function S() {
        const e = r.params.zoom, s = v.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio;
        if (e.limitToOriginalSize && v.imageEl && v.imageEl.naturalWidth) {
            const e = v.imageEl.naturalWidth / v.imageEl.offsetWidth;
            return Math.min(e, s);
        }
        return s;
    }

    function T(e) {
        const s = r.isElement ? "swiper-slide" : `.${r.params.slideClass}`;
        return !!e.target.matches(s) || r.slides.filter((t => t.contains(e.target))).length > 0;
    }

    function M(e) {
        const s = `.${r.params.zoom.containerClass}`;
        return !!e.target.matches(s) || [...r.hostEl.querySelectorAll(s)].filter((t => t.contains(e.target))).length > 0;
    }

    function C(e) {
        if ("mouse" === e.pointerType && g.splice(0, g.length), !T(e)) return;
        const s = r.params.zoom;
        if (h = !1, f = !1, g.push(e), !(g.length < 2)) {
            if (h = !0, v.scaleStart = x(), !v.slideEl) {
                v.slideEl = e.target.closest(`.${r.params.slideClass}, swiper-slide`), v.slideEl || (v.slideEl = r.slides[r.activeIndex]);
                let a = v.slideEl.querySelector(`.${s.containerClass}`);
                if (a && (a = a.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), v.imageEl = a, v.imageWrapEl = a ? E(v.imageEl, `.${s.containerClass}`)[0] : void 0, !v.imageWrapEl) return void(v.imageEl = void 0);
            }
            if (v.imageEl) {
                const [e, t] = function() {
                    if (g.length < 2) return {
                        x: null,
                        y: null
                    };
                    const e = v.imageEl.getBoundingClientRect();
                    return [(g[0].pageX + (g[1].pageX - g[0].pageX) / 2 - e.x - n.scrollX) / d, (g[0].pageY + (g[1].pageY - g[0].pageY) / 2 - e.y - n.scrollY) / d];
                }();
                v.originX = e, v.originY = t, v.imageEl.style.transitionDuration = "0ms";
            }
            c = !0;
        }
    }

    function P(e) {
        if (!T(e)) return;
        const s = r.params.zoom, a = r.zoom, i = g.findIndex((t => t.pointerId === e.pointerId));
        i >= 0 && (g[i] = e), g.length < 2 || (f = !0, v.scaleMove = x(), v.imageEl && (a.scale = v.scaleMove / v.scaleStart * d, a.scale > v.maxRatio && (a.scale = v.maxRatio - 1 + (a.scale - v.maxRatio + 1) ** .5), a.scale < s.minRatio && (a.scale = s.minRatio + 1 - (s.minRatio - a.scale + 1) ** .5), v.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`));
    }

    function L(e) {
        if (!T(e)) return;
        if ("mouse" === e.pointerType && "pointerout" === e.type) return;
        const s = r.params.zoom, a = r.zoom, i = g.findIndex((t => t.pointerId === e.pointerId));
        i >= 0 && g.splice(i, 1), h && f && (h = !1, f = !1, v.imageEl && (a.scale = Math.max(Math.min(a.scale, v.maxRatio), s.minRatio), v.imageEl.style.transitionDuration = `${r.params.speed}ms`, v.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`, d = a.scale, c = !1, a.scale > 1 && v.slideEl ? v.slideEl.classList.add(`${s.zoomedSlideClass}`) : a.scale <= 1 && v.slideEl && v.slideEl.classList.remove(`${s.zoomedSlideClass}`), 1 === a.scale && (v.originX = 0, v.originY = 0, v.slideEl = void 0)));
    }

    function I() {
        r.touchEventsData.preventTouchMoveFromPointerMove = !1;
    }

    function z(e) {
        const s = "mouse" === e.pointerType && r.params.zoom.panOnMouseMove;
        if (!T(e) || !M(e)) return;
        const a = r.zoom;
        if (!v.imageEl) return;
        if (!w.isTouched || !v.slideEl) return void(s && O(e));
        if (s) return void O(e);
        w.isMoved || (w.width = v.imageEl.offsetWidth || v.imageEl.clientWidth, w.height = v.imageEl.offsetHeight || v.imageEl.clientHeight, w.startX = d(v.imageWrapEl, "x") || 0, w.startY = d(v.imageWrapEl, "y") || 0, v.slideWidth = v.slideEl.offsetWidth, v.slideHeight = v.slideEl.offsetHeight, v.imageWrapEl.style.transitionDuration = "0ms");
        const i = w.width * a.scale,
            n = w.height * a.scale;
        w.minX = Math.min(v.slideWidth / 2 - i / 2, 0), w.maxX = -w.minX, w.minY = Math.min(v.slideHeight / 2 - n / 2, 0), w.maxY = -w.minY, w.touchesCurrent.x = g.length > 0 ? g[0].pageX : e.pageX, w.touchesCurrent.y = g.length > 0 ? g[0].pageY : e.pageY;
        if (Math.max(Math.abs(w.touchesCurrent.x - w.touchesStart.x), Math.abs(w.touchesCurrent.y - w.touchesStart.y)) > 5 && (r.allowClick = !1), !w.isMoved && !c) {
            if (r.isHorizontal() && (Math.floor(w.minX) === Math.floor(w.startX) && w.touchesCurrent.x < w.touchesStart.x || Math.floor(w.maxX) === Math.floor(w.startX) && w.touchesCurrent.x > w.touchesStart.x)) return w.isTouched = !1, void I();
            if (!r.isHorizontal() && (Math.floor(w.minY) === Math.floor(w.startY) && w.touchesCurrent.y < w.touchesStart.y || Math.floor(w.maxY) === Math.floor(w.startY) && w.touchesCurrent.y > w.touchesStart.y)) return w.isTouched = !1, void I();
        }
        e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(y), r.touchEventsData.preventTouchMoveFromPointerMove = !0, y = setTimeout((() => {
            r.destroyed || I();
        })), w.isMoved = !0;
        const l = (a.scale - d) / (v.maxRatio - r.params.zoom.minRatio), {
            originX: o,
            originY: p
        } = v;
        w.currentX = w.touchesCurrent.x - w.touchesStart.x + w.startX + l * (w.width - 2 * o), w.currentY = w.touchesCurrent.y - w.touchesStart.y + w.startY + l * (w.height - 2 * p), w.currentX < w.minX && (w.currentX = w.minX + 1 - (w.minX - w.currentX + 1) ** .8), w.currentX > w.maxX && (w.currentX = w.maxX - 1 + (w.currentX - w.maxX + 1) ** .8), w.currentY < w.minY && (w.currentY = w.minY + 1 - (w.minY - w.currentY + 1) ** .8), w.currentY > w.maxY && (w.currentY = w.maxY - 1 + (w.currentY - w.maxY + 1) ** .8), b.prevPositionX || (b.prevPositionX = w.touchesCurrent.x), b.prevPositionY || (b.prevPositionY = w.touchesCurrent.y), b.prevTime || (b.prevTime = Date.now()), b.x = (w.touchesCurrent.x - b.prevPositionX) / (Date.now() - b.prevTime) / 2, b.y = (w.touchesCurrent.y - b.prevPositionY) / (Date.now() - b.prevTime) / 2, Math.abs(w.touchesCurrent.x - b.prevPositionX) < 2 && (b.x = 0), Math.abs(w.touchesCurrent.y - b.prevPositionY) < 2 && (b.y = 0), b.prevPositionX = w.touchesCurrent.x, b.prevPositionY = w.touchesCurrent.y, b.prevTime = Date.now(), v.imageWrapEl.style.transform = `translate3d(${w.currentX}px, ${w.currentY}px,0)`;
    }

    function A() {
        const e = r.zoom;
        e.scale && 1 !== e.scale ? G() : D(e);
    }

    function $(e) {
        return "string" == typeof e ? e : `${e}px`;
    }
    me({
        effect: "creative",
        swiper: r,
        on: l,
        setTranslate: () => {
            const {
                slides: e,
                wrapperEl: s,
                slidesSizesGrid: a
            } = r, i = r.params.creativeEffect, {
                progressMultiplier: n
            } = i, l = r.params.centeredSlides, o = M(r);
            if (l) {
                const e = a[0] / 2 - r.params.slidesOffsetBefore || 0;
                s.style.transform = `translateX(calc(50% - ${e}px))`;
            }
            for (let s = 0; s < e.length; s += 1) {
                const a = e[s], d = a.progress, c = Math.min(Math.max(a.progress, -i.limitProgress), i.limitProgress);
                let p = c;
                l || (p = Math.min(Math.max(a.originalProgress, -i.limitProgress), i.limitProgress));
                const u = a.swiperSlideOffset, m = [r.params.cssMode ? -u - r.translate : -u, 0, 0], h = [0, 0, 0];
                let f = !1;
                r.isHorizontal() || (m[1] = m[0], m[0] = 0);
                let g = {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    scale: 1,
                    opacity: 1
                };
                c < 0 ? (g = i.next, f = !0) : c > 0 && (g = i.prev, f = !0), m.forEach(((e, t) => {
                    m[t] = `calc(${e}px + (${$(g.translate[t])} * ${Math.abs(c*n)}))`;
                })), h.forEach(((e, t) => {
                    let s = g.rotate[t] * Math.abs(c * n);
                    h[t] = s;
                })), a.style.zIndex = -Math.abs(Math.round(d)) + e.length;
                const v = m.join(", "), w = `rotateX(${o(h[0])}deg) rotateY(${o(h[1])}deg) rotateZ(${o(h[2])}deg)`, b = c < 0 ? `scale(${1+(1-g.scale)*c*n})` : `scale(${1-(1-g.scale)*c*n})`, y = c < 0 ? 1 + (1 - g.opacity) * c * n : 1 - (1 - g.opacity) * c * n, E = `translate3d(${v}) ${w} ${b}`;
                if (f && g.shadow || !f) {
                    let e = a.querySelector(".swiper-slide-shadow");
                    if (!e && g.shadow && (e = ge("creative", a)), e) {
                        const t = i.shadowPerProgress ? c * (1 / i.limitProgress) : c;
                        e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1);
                    }
                }
                const x = he(0, a);
                x.style.transform = E, x.style.opacity = y, g.origin && (x.style.transformOrigin = g.origin);
            }
        },
        setTransition: e => {
            const s = r.slides.map((e => h(e)));
            s.forEach((t => {
                t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                    t.style.transitionDuration = `${e}ms`;
                }));
            })), fe({
                swiper: r,
                duration: e,
                transformElements: s,
                allSlides: !0
            });
        },
        perspective: () => r.params.creativeEffect.perspective,
        overwriteParams: () => ({
            watchSlidesProgress: !0,
            virtualTranslate: !r.params.cssMode
        })
    });
}, function(e) {
    let {
        swiper: t,
        extendParams: s,
        on: a
    } = e;
    s({
        cardsEffect: {
            slideShadows: !0,
            rotate: !0,
            perSlideRotate: 2,
            perSlideOffset: 8
        }
    }), me({
        effect: "cards",
        swiper: t,
        on: a,
        setTranslate: () => {
            const {
                slides: e,
                activeIndex: s,
                rtlTranslate: a
            } = t, i = t.params.cardsEffect, {
                startTranslate: r,
                isTouched: n
            } = t.touchEventsData, l = a ? -t.translate : t.translate;
            for (let o = 0; o < e.length; o += 1) {
                const d = e[o], c = d.progress, p = Math.min(Math.max(c, -4), 4);
                let u = d.swiperSlideOffset;
                t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset);
                let m = t.params.cssMode ? -u - t.translate : -u, h = 0;
                const f = -100 * Math.abs(p);
                let g = 1, v = -i.perSlideRotate * p, w = i.perSlideOffset - .75 * Math.abs(p);
                const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o, y = (b === s || b === s - 1) && p > 0 && p < 1 && (n || t.params.cssMode) && l < r, E = (b === s || b === s + 1) && p < 0 && p > -1 && (n || t.params.cssMode) && l > r;
                if (y || E) {
                    const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5;
                    v += -28 * p * e, g += -.5 * e, w += 96 * e, h = -25 * e * Math.abs(p) + "%";
                }
                if (m = p < 0 ? `calc(${m}px ${a?"-":"+"} (${w*Math.abs(p)}%))` : p > 0 ? `calc(${m}px ${a?"-":"+"} (-${w*Math.abs(p)}%))` : `${m}px`, !t.isHorizontal()) {
                    const e = h;
                    h = m, m = e;
                }
                const x = p < 0 ? "" + (1 + (1 - g) * p) : "" + (1 - (1 - g) * p), S = `\n        translate3d(${m}, ${h}, ${f}px)\n        rotateZ(${i.rotate?a?-v:v:0}deg)\n        scale(${x})\n      `;
                if (i.slideShadows) {
                    let e = d.querySelector(".swiper-slide-shadow");
                    e || (e = ge("cards", d)), e && (e.style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1));
                }
                d.style.zIndex = -Math.abs(Math.round(c)) + e.length;
                he(0, d).style.transform = S;
            }
        },
        setTransition: e => {
            const s = t.slides.map((e => h(e)));
            s.forEach((t => {
                t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                    t.style.transitionDuration = `${e}ms`;
                }));
            })), fe({
                swiper: t,
                duration: e,
                transformElements: s
            });
        },
        perspective: () => !0,
        overwriteParams: () => ({
            _loopSwapReset: !1,
            watchSlidesProgress: !0,
            loopAdditionalSlides: t.params.cardsEffect.rotate ? 3 : 2,
            centeredSlides: !0,
            virtualTranslate: !t.params.cssMode
        })
    });
}];
return re.use(ve), re;
}();